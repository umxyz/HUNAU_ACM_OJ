CREATE DATABASE  IF NOT EXISTS `jnoj` /*!40100 DEFAULT CHARACTER SET latin1 */;
USE `jnoj`;
-- MySQL dump 10.13  Distrib 8.0.18, for Win64 (x86_64)
--
-- Host: 172.28.210.177    Database: jnoj
-- ------------------------------------------------------
-- Server version	5.7.28-0ubuntu0.18.04.4

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `polygon_problem`
--

DROP TABLE IF EXISTS `polygon_problem`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `polygon_problem` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `description` text COLLATE utf8_unicode_ci,
  `input` text COLLATE utf8_unicode_ci,
  `output` text COLLATE utf8_unicode_ci,
  `sample_input` text COLLATE utf8_unicode_ci,
  `sample_output` text COLLATE utf8_unicode_ci,
  `spj` smallint(1) DEFAULT '0',
  `spj_lang` smallint(6) DEFAULT NULL,
  `spj_source` text COLLATE utf8_unicode_ci,
  `hint` text COLLATE utf8_unicode_ci,
  `source` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `time_limit` int(11) DEFAULT NULL,
  `memory_limit` int(11) DEFAULT NULL,
  `status` smallint(6) DEFAULT '0',
  `accepted` int(11) DEFAULT '0',
  `submit` int(11) DEFAULT '0',
  `solved` int(11) DEFAULT '0',
  `tags` text COLLATE utf8_unicode_ci,
  `solution` text COLLATE utf8_unicode_ci,
  `solution_lang` smallint(6) DEFAULT NULL,
  `solution_source` text COLLATE utf8_unicode_ci,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  `created_by` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_created_by` (`created_by`)
) ENGINE=InnoDB AUTO_INCREMENT=60 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `polygon_problem`
--

LOCK TABLES `polygon_problem` WRITE;
/*!40000 ALTER TABLE `polygon_problem` DISABLE KEYS */;
INSERT INTO `polygon_problem` VALUES (7,'zyt的疑惑','<p>zyt特别有钱，现在他手上有无数个两种面值均为正整数的票子，现在他去商店买肖潇，仅凭这两种面值的票票有些肖潇他是无论如何也无法凑出钱来买的，并且商店老板没有现金可以找零，而且zyt数学学得不怎么好。你在这些他无法凑出钱来买的肖潇中，最贵的肖潇要多少票子</p>','<p>第一行输入两个数</p>','<p>输入结果以换行符结束</p>','a:3:{i:0;s:3:\"3 7\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:2:\"11\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>zyt大佬手中有面值为3和7的票票有无数个，他买不了面值为1,2,4,5,8,11的东东，其中最贵的东东价值为1，比11贵的东东都能买到，比如</p><p>12 = 3 * 4 + 7 * 0&nbsp;&nbsp;</p><p>13 = 3 * 2 + 7 * 1&nbsp;&nbsp;</p><p>14 = 3 * 0 + 7 *</p><p>2&nbsp; 15 = 3 * 5 + 7 * 0 ……</p><p>对于 30%的数据： 1 ≤ a，b ≤ 50。</p><p>&nbsp;对于 60%的数据： 1 ≤ a，b ≤ 10,000。&nbsp;</p><p>对于 100%的数据：1 ≤ a，b ≤ 1,000,000,000</p>',NULL,1,256,0,0,0,0,'数论',NULL,1,'','2019-10-20 11:08:58','2019-10-20 13:43:13',6),(8,'geometric preliminary','<p>This is a mentally retarded question. There is a circle in a Cartesian coordinate system(平面直角坐标系） with the center of the circle at (0,0). Give you the two coordinates a, b on the circle. The title guarantees that a and b are all on a circle, and now let you find the length of the ab Arc length。</p>','<p>a,b</p><p>Two point coordinates</p>','<p>Two points correspond to the length of the arc, and two decimal places are reserved.</p>','a:3:{i:0;s:8:\"0 1\r\n1 0\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:4:\"1.57\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>思考怎样快速求出对应的角度。推荐使用acos。注意求的是劣弧。</p>',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\nint main(){\r\n    int x1,y1,x2,y2;\r\n    scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);//aç‚¹å’Œbç‚¹\r\n    double r=sqrt(x1*x1+y1*y1);\r\n    double th=acos((x1*x2+y1*y2)/(r*r));//?????\r\n    printf(\"%.2lf\",r*th);\r\n    return 0;\r\n}','2019-10-23 21:25:35','2019-10-23 21:31:45',6),(9,'maximum profit','<p>exchange trade can earn the exchange rate difference through the currencies of different countries. For example, if you buy 1000 dollars when the exchange rate of one dollar changes to 100 Japanese yen, and then you sell when the exchange rate changes to 108 Japanese yen when the exchange rate of one dollar changes to 108 Japanese yen, you can make a profit (108-100) * 1000 = 8000 US dollars. Now, take the price Rt(t = 0,1,.. n-1) of a currency at time t as the input data, and calculate the maximum value of the price difference Rj-Ri（j&gt;i）</p>','<p>Input the integer n in the first line, and input the next N lines in turn Rt(t = 0,1... N-1).</p>','<p>Output answer</p>','a:3:{i:0;s:19:\"6\r\n5\r\n3\r\n1\r\n3\r\n4\r\n3\";i:1;s:11:\"3\r\n4\r\n3 \r\n2\";i:2;s:0:\"\";}','a:3:{i:0;s:1:\"3\";i:1;s:2:\"-1\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>1&lt;n&lt;200000</p><p>0&lt;Rt&lt;10^9</p>',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-23 21:42:37','2019-10-23 21:58:45',6),(10,'Base16','<p>Both hexadecimal and binary are necessary for us to master in our life and study. Now I will give you a hexadecimal number. Please find the corresponding binary number.</p>','<p>A hexadecimal number n.n&lt;10^3000</p>','<p>binary of n</p>','a:3:{i:0;s:2:\"FB\";i:1;s:2:\"45\";i:2;s:2:\"4F\";}','a:3:{i:0;s:8:\"11111011\";i:1;s:8:\"01000101\";i:2;s:8:\"01001111\";}',0,NULL,NULL,'<p>\'A\'represent10,\'B\'represent 11，and so on</p>',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-23 22:38:11','2019-10-23 22:42:36',6),(11,'打铁工程师','<p>Zlw大佬是一位专业打铁的工程师，负责一条长度为n的道路。</p><p>大佬的主工作就是天平下陷的地表，整段道路可以看做是n块首尾相连的区域，zlw大佬还没有开始打铁之前，第i块区域的下陷深度为di</p><p>打铁师每天可以选择一段连续的区间[<i>L</i>,<i>R</i>]，填充这块区域每块区域，让其下陷深度减少1,。选择区间的时候要保证，[<i>L</i>,<i>R</i>]的每块在填充前的下陷深度均不为零。</p><p>Zlw大佬忙于学业，想请宁计算一下在最短的时间内讲整块道路的下陷深度都变为零。</p>','<p>输入文件包含两行，第一行包含一个整数 n，表示道路的长度。 第二行包含 n 个整数，相邻两数间用一个空格隔开，第 i 个整数为 di</p>','<p>输出文件仅包含一个整数，即最少需要多少天才能完成任务。</p>','a:3:{i:0;s:16:\"6\r\n4 3 2 5 3 5\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:3:\"9\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,512,0,0,0,0,'',NULL,NULL,NULL,'2019-10-24 12:45:01','2019-10-24 12:47:53',6),(12,'又一个小米6坠机了','<p>又一个小米6坠机了，雷总又在远程施法。现在雷总正在远征施法，小米6用户瑟瑟发抖，当然现在小米6用户可以有一个办法防止雷总施法生效。现在有一个小米6用户xx想请宁帮一下他。防止远程施法的办法如下：雷总现在正在念一句咒语。而为了防止xx的米6坠机，他需要统计给定单词在雷总的咒语中出现的次数以及第一次出现的位置（注意这个咒语的匹配不区分大小写）</p><figure class=\"image\"><img src=\"/uploads/20191024/1571892902938.gif\"></figure><figure class=\"image\"><img src=\"/uploads/20191024/15718929029089.gif\"></figure><figure class=\"image\"><img src=\"/uploads/20191024/15718929023144.jpg\"></figure>','<p>第1行为一个字符串，其中只含字母，表示给定单词；</p><p>第2行为一个字符串，其中只可能包含字母和空格，表示给定的雷总的咒语。</p>','<p>&nbsp;</p>','a:3:{i:0;s:36:\"To\r\nto be or not to be is a question\";i:1;s:54:\"to\r\nDid the Ottoman Empire lose its power at that time\";i:2;s:0:\"\";}','a:3:{i:0;s:5:\"2 0\r\n\";i:1;s:2:\"-1\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-24 12:53:37','2019-10-25 18:43:05',6),(14,'Xx吃香蕉','<p>Xx家的后面有一颗香蕉树，没到秋天，树上就会结出10个很大的香蕉。这10个大香蕉就会吸引xx跑过去摘香蕉。Xx有30厘米的板凳，当她不能用手摘到香蕉的时候，就会踩到板凳上再去试一试。</p><p>现在知道了10个香蕉的高度，和xx把手伸直的时候可以碰到的最大高度，xx等着摘香蕉这一天等了很久了，so请宁计算一下xx可以摘到多少个香蕉。</p><p>现在假设xx一碰到香蕉香蕉马上就会掉下来。</p>','<p>输入数据各两行：</p><p>第一行为10个数字分别表示十个苹果的高度，每两个数据之间用一个空格隔开。</p><p>第二行为xx踩到板凳上用手可以碰到的高度。</p>','<p>输出包括一行，只有一个整数，表示xx能够摘到的香蕉的数目。</p>','a:3:{i:0;s:46:\"100 200 150 140 129 134 167 198 200 111\r\n110\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:3:\"5\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-24 13:07:57','2019-10-28 11:28:28',6),(15,'农大路上的树','<p>农大的校园的有一条马路上有长度为L的马路上有一排树，相邻的树之间都间隔一米，把马路看成数轴，一端在数轴0的位置，一端在L 的位置。数轴上每一个整数点都种了一棵树。</p><p>由于农大校园的这条路上有一些要修路需要移走一些树，现在这些区域用它们在数轴上的起始点和终止点表示。并且已知所有的树所在的左边全是整数。区间之间有可能有重合的部分，现在要把区间中的树移走，（包括端点处的两棵树）。宁的任务是，移走这些树之后，马路上还剩多少颗树。</p>','<p>第一行有22个整数L (1≤L≤10000)和 M(1≤M≤100)，L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。</p><p>接下来的M行每行包含2个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。</p>','<p>1个整数，表示马路上剩余的树的数目。</p>','a:3:{i:0;s:34:\"500 3\r\n150 300\r\n100 200\r\n470 471\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:5:\"298\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-24 13:12:00','2019-10-24 13:12:27',6),(16,'who is the most dl',NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-24 13:20:31','2019-10-24 13:20:31',6),(17,'肖潇数列','<p>相信大家都听过著名的斐波那契数列，但是肖潇觉得这个数列太没意思，于是他对数列做了一些改动，称之为肖潇数列。</p><p>我们所知道的斐波那契数列定义为：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）</p><p>现在肖潇任意给出F（0）和F（1）以及一个常数C，你能求出第n项湖南农大数列的值是否为C的倍数吗？</p>','<p>输入包含多组样例，每组样例输入F(0)，F(1)，C，n。0&lt;F(0),F(1)&lt;10^18，0&lt;C&lt;10，0&lt;n&lt;10^6</p>','<p>如果F（n）是C的倍数，那么输出yes，否则输出no</p>','a:3:{i:0;s:40:\"7 11 3 2\r\n999999999999 123456789 8 100\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:9:\"yes\r\nno\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>数据量有点多，不过这个题依然很简单，仔细思考下吧</p>',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-30 10:51:59','2019-10-30 10:54:16',5),(18,'肖潇三角','<p>肖潇三角形的特点是两个腰上的数字都为1，其它位置上的数字是其上一行中与之相邻的两个整数之和。所以在打印过程中，第i行上的元素要由第i-1行中的元素来生成。</p>','<p>第1行为一个整数t(1≤t≤10),表示接下来有t 个测试数据。 第2行输入要输出的杨辉三角形的行数。</p>','<p>肖潇三角的每一行。</p>','a:3:{i:0;s:7:\"1\r\n15\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:378:\"1\r\n1 1\r\n1 2 1\r\n1 3 3 1\r\n1 4 6 4 1\r\n1 5 10 10 5 1\r\n1 6 15 20 15 6 1\r\n1 7 21 35 35 21 7 1\r\n1 8 28 56 70 56 28 8 1\r\n1 9 36 84 126 126 84 36 9 1\r\n1 10 45 120 210 252 210 120 45 10 1\r\n1 11 55 165 330 462 462 330 165 55 11 1\r\n1 12 66 220 495 792 924 792 495 220 66 12 1\r\n1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1\r\n1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>数据很大，用 long long类型</p>',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-10-30 10:58:09','2019-10-30 10:59:07',5),(19,'找数字','<p>模拟赛比完了, 肖潇大佬需要从其中找出某些特别优秀和不够努力的人出来</p>','<p>第一行有一个正整数表示测试用例的个数。</p><p>对于每个测试用例，有2行，第一行有2个正整数n,k，n表示数据的个数，0&lt;k&lt;=n&lt;=1000000。其后有n个整数，每个整数不大于10的9次方。</p>','<p>每个测试用例输出一行。</p>','a:3:{i:0;s:93:\"5\r\n6 1\r\n6 5 4 3 2 1\r\n6 6\r\n2 3 1 4 6 5\r\n6 3\r\n2 4 5 3 6 1\r\n6 1\r\n1 1 1 1 1 1\r\n6 6\r\n1 1 1 1 1 1\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:15:\"1\r\n6\r\n3\r\n1\r\n1\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>注意时间复杂度 总有一种不超时的排序算法</p>',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n;\r\n    scanf(\"%d\", &n);\r\n    while(n--)\r\n    {\r\n        int MAX_SIZE, k;\r\n        cin >> MAX_SIZE >> k;\r\n        vector<int> sz(MAX_SIZE,0);\r\n        for (int i = 0; i < MAX_SIZE; i++)\r\n            scanf(\"%d\", &sz[i]);\r\n        nth_element(sz.begin(), sz.begin() + k - 1, sz.end());\r\n        cout << sz[k - 1] << endl;\r\n    }\r\n    return 0;\r\n}','2019-10-30 11:08:13','2019-11-05 13:58:04',5),(20,'肖潇矩阵','<p>肖潇大佬 创造了一个 $n$ 行 $m$ 列的矩阵 $A_{i, j}$, 该矩阵有以下两条规矩</p><p>• 所有元素 $A_{i, j}$ ($1 \\leq i \\leq n, 1 \\leq j \\leq m$) 设为 0.<br>• 有$4$ 个整数 $x_1, x_2, y_1, y_2$ 满足 $1 \\leq x_1 \\leq x_2 \\leq n, 1 \\leq y_1 \\leq y_2 \\leq m$，并把满足 $x_1 \\leq i \\leq x_2, y_1 \\leq j \\leq y_2$ 的元素 $A_{i, j}$ 设为 1.<br>给给出 $n$ 行 $m$ 列的矩阵 $A_{i, j}$, 判断它是否是 肖潇大佬 所写的矩阵。</p>','<p>输入文件包含多组数据，请处理到文件结束。</p><p>每组数据的第一行包含两个整数 $n$ 和 $m$.</p><p>接下来 $n$ 行，其中第 $i$ 行包含 $m$ 个整数 $A_{i, 1}, A_{i, 2}, \\dots, A_{i, m}$.</p><p>* $1 \\leq n, m \\leq 100$<br>* $A_{i, j} \\in \\{0, 1\\}$<br>* 至多 $1000$ 组数据。</p>','<p>对于每组数据，如果该矩阵是 肖潇大佬 的矩阵，输出 Yes, 否则输出 No.&nbsp;</p>','a:3:{i:0;s:56:\"2 2\r\n11\r\n10\r\n3 3\r\n000\r\n001\r\n000\r\n3 4\r\n1111\r\n1111\r\n1111\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:14:\"No\r\nYes\r\nYes\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\n\r\nint main() {\r\n  int n, m;\r\n  while (scanf(\"%d%d\", &n, &m) == 2) {\r\n    std::vector<std::vector<char>> g(n + 2, std::vector<char>(m + 2, \'0\'));\r\n    for (int i = 1; i <= n; ++i) {\r\n      std::vector<char> buffer(m + 1);\r\n      scanf(\"%s\", buffer.data());\r\n      std::copy(buffer.begin(), buffer.end(), g[i].begin() + 1);\r\n    }\r\n    std::array<int, 5> count;\r\n    std::fill(count.begin(), count.end(), 0);\r\n    for (int i = 0; i <= n; ++i) {\r\n      for (int j = 0; j <= m; ++j) {\r\n        int c = 0;\r\n        for (int x = 0; x < 2; ++x) {\r\n          for (int y = 0; y < 2; ++y) {\r\n            c += (g[i + x][j + y] == \'1\');\r\n          }\r\n        }\r\n        count[c]++;\r\n      }\r\n    }\r\n    bool ok = true;\r\n    ok &= count[1] == 4;\r\n    ok &= count[3] == 0;\r\n    puts(ok ? \"Yes\" : \"No\");\r\n  }\r\n}\r\n','2019-11-04 10:46:01','2019-11-04 13:44:45',5),(21,'我的头又铁了','<p>铁头娃dxx每天在实验室刚题目，强势把二维压一维。因为头很铁，所以总是享受wa的快感，他天天修炼已经练成了玄学大法，每天只要默念咒语就可以ak所有题目。</p><p>现在铁头娃又在念咒语了。他想找你作为他的施法对象祝你ac了这一道题目。如果dxx说“谁才是大佬”，你就要回答“lw是大佬”。如果他问“谁才是真正的dl”，你就要回答“hzx才是真正的大佬”，如果他问“谁才是最dl”，你就要回答“dxx才是最dl”。</p>','<p>第一行一个数字n表示有n组测试数据</p><p>接下来第2-n+1行有n句话。</p>','<p>输出有n行，相应的回答。</p>','a:3:{i:0;s:97:\"6\r\n谁才是最dl\r\n谁才是最dl\r\n谁才是最dl\r\n谁才是最dl\r\n谁才是最dl\r\n谁才是最dl\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:96:\"dxx才是最dl\r\ndxx才是最dl\r\ndxx才是最dl\r\ndxx才是最dl\r\ndxx才是最dl\r\ndxx才是最dl\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-11-04 15:18:23','2019-11-10 09:07:18',6),(22,'肖潇大佬也是网管','<p>IP地址分配是网络管理员必须掌握的知识。对于给定的网段，必须清楚能分配哪些IP地址给计算机。</p><p>目前使用的IP地址采用4个小节构成，每个小节为取值范围在[0,255]的一个整数。</p><p>因为IP地址的小节值为255有特殊用途，例如用作广播地址，所以一般不分配给普通的计算机作为IP地址使用。</p><p>某个网络中，对IP地址分配有如下要求，IP地址的前3个小节已经固定为192.168.1.X，只有最后小节中的X是你所能安排的。</p><p>并且规定了IP地址192.168.1.1为此网段的网关的IP地址，此地址不能分配给其他计算机。</p><p>现在给定网络中需要分配IP地址的计算机的台数n，要求你从IP地址192.168.1.2开始，连续分配n个IP地址。</p><p>若所需安排的计算机数量n大于等于254，那么无法按照以上要求给n台计算机全部分配IP，此时输出\"Error”（注意输出后要换行）。</p>','<p>第一行，一个n(1&lt;=n&lt;=65535)，表示需要分配IP地址的电脑总数。</p>','<p>n行，每行一个按从小到大顺序安排好的IP地址。</p>','a:3:{i:0;s:3:\"2\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:26:\"192.168.1.2\r\n192.168.1.3\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>注意考虑各种情况</p>',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-11-05 13:52:19','2019-11-05 13:53:10',5),(23,'字符串解码','<p>有一个二进制数，按每八位为一组进行解码转换成ASCII值的字符</p>','<p>多组八位的二进制数</p>','<p>输出解码信息</p>','a:3:{i:0;s:26:\"011000100110011101110110\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:5:\"bgv\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-11-05 17:28:31','2019-11-05 17:28:56',5),(24,'查验身份证','<p>在大家使用的身份证都是18位号码，其实就在几年以前，身份证都是使用的15位号码。</p><p>全中国十几亿人都要将15位的身份证号升至18位，工作量之大可想而知。现在假如你回到了身份证升位的时期，当地一个公安局想请你设计一款软件实现自动升位。</p><p>升位方法：将原十五位身份证出生年份由原来的2位升至4位（比如81升为1981，假设所有身份证的主人为1900-1999年出生）得到17位身份证码，再根据17位身份证码计算校验码，校验码加至号码尾即得18位身份证号码。</p><p>校验码是由十七位身份证码生成，生成方法如下：</p><p>校验码公式： V=(∑(ai×Wi)) (mod 11) 2≤i≤18……………………………………(1)</p><p>其中， i----表示号码字符从右至左包括校验码在内的位置序号；</p><p>ai----表示第i位置上的号码数值；</p><p>Wi----示第i位置上的加权因子(其值已定)，其数值依据公式Wi=2^(i-1)(mod 11)计算得出，其中x^y表示x的y次幂，x mod y表示x除以y的余数，也就是说，Wi为(2的(i-1)次方)除以11的余数。</p><p>以34052419800101001C为例，其中C为校验码。</p><p>下面说明如何计算校验码：</p><p>计算校验码的编号，位置序号为从右到左包括校验位在内进行计算的。</p><p>身份证号: &nbsp;3 &nbsp; 4 &nbsp; 0 &nbsp; 5 &nbsp; 2 &nbsp; 4 &nbsp; 1 &nbsp; 9 &nbsp; 8 &nbsp;0 &nbsp;0 &nbsp;1 &nbsp;0 &nbsp;1 &nbsp;0 &nbsp;0 &nbsp;1 C</p><p>位置序号:18 17 16 15 14 13 12 11 10 &nbsp;9 &nbsp;8 &nbsp;7 &nbsp;6 &nbsp;5 &nbsp;4 &nbsp;3 &nbsp;2</p><p>根据公式(1)进行计算：</p><p>V=( 3*(2^(18-1) mod 11)+4*(2^(17-1) mod 11)+...+1*(2^(2-1) mod 11) ) &nbsp;mod 11</p><p>&nbsp; =(21+36+0+25+16+16+2+9+48++0+0+9+0+5+0+0+2) mod 11</p><p>&nbsp; = 2</p><p>然后根据计算的结果V=2，查下校验码表得，</p><p>校验码对应表</p><p>&nbsp; &nbsp; V的值： 0 1 2 3 4 5 6 7 8 9 10</p><p>校验码C： 1 0 X 9 8 7 6 5 4 3 2</p><p>查表V=2的校验码为X，所以18位号码为：34052419800101001X</p>','<p>输入第一行给出正整数<i>N</i>（≤100）是输入的身份证号码的个数。随后<i>N</i>行，每行给出1个18位身份证号码。</p>','<p>按照输入的顺序检查每行输入的身份证号码。如果某一行的身份证不正确（只检查身份证最后一位的校验码是否正确就行了）输出正确的身份证，如果所有号码都正常，则输出<code>All passed</code>。</p>','a:3:{i:0;s:63:\"3\r\n34052419800101001X\r\n43010419891010253X\r\n430902198712208036\r\n\";i:1;s:61:\"3\r\n34052419800101001X\r\n430104198910102530\r\n430902198712208036\";i:2;s:0:\"\";}','a:3:{i:0;s:20:\"430104198910102530\r\n\";i:1;s:12:\"All passed\r\n\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-11-05 22:06:26','2019-11-05 22:25:40',5),(25,'不想做肥宅的肖潇','<p>已知男大学生的标准身高为 176 厘米、标准体重为 60 公斤；女大学生的标准身高为 164 厘米、标准体重为 50 公斤。&nbsp;<br>现在你要根据身高体重，给出建议。</p>','<p>第一行输入测试数据个数 N (N&lt;=100)&nbsp;<br>随后 N 行，输入 每一位大学生的 性别 身高 体重&nbsp;<br>其中性别是 1 表示男生，0 表示女生。身高和体重都是不超过 200 的正整数。</p>','<p>对于每一位大学生，在一行中给出你的建议：&nbsp;<br><br>如果太矮了，输出：Drink more milk!（多喝牛奶）&nbsp;<br>如果太瘦了，输出：Eat more meat!（多吃肉）&nbsp;<br>如果正标准，输出：U R hot!（你很性感）&nbsp;<br>如果太高了，输出：U R tall!（你很高）&nbsp;<br>如果太胖了，输出：U R steady!（你很稳重）&nbsp;<br>先评价身高，再评价体重。两句话之间要有 1 个空格。</p>','a:3:{i:0;s:0:\"\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:0:\"\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-11-06 01:17:01','2019-11-06 01:49:39',5),(26,'Simple question','<p>There are three questions here:</p><p>1.The total value of a pair of rackets and a ball is $ x $ dollars, and the racket is more expensive than the ball by $ y $ dollars.</p><p>2. If $ x $ machines can produce $ a $ part in $ m $ minutes, how many minutes does $ y $ machine need to produce $ b $ parts?</p><p>3. There is a water lily in a lake, and the area of water lily expands $ x $ times every day. If it takes $ y $ days for the water lily to cover the entire lake, how many days does it need to cover $ z $ lakes?</p>','<p>Enter the number of cases in the first line.</p><p>Enter the problem serial number in the second line.</p><p>Enter the relevant unknowns in the third line.</p>','<p>Output answer value One number per line.</p>','a:3:{i:0;s:43:\"3\r\n1\r\n1.5 1\r\n2\r\n5 5 5 100 99\r\n3\r\n1 48 0.4\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:19:\"0.25\r\n4.95\r\n46.00\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>Output is reserved to 2 decimal places.Consider special cases (data range (0 - 2.22507e-308(double max)))</p>',NULL,1,128,0,0,0,0,'',NULL,1,'/*\r\n * @Author: ZengChenyu\r\n * @Mail: zcy229781766@gmail.com\r\n * @Github: https://github.com/yuuxeun\r\n * @Date: 2019-05-07 00:20:57\r\n * @LastEditors: ZengChenyu\r\n * @LastEditTime: 2019-08-27 01:57:39\r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n// double JudgeProblem(int problem_numbers)\r\nvoid JudgeProblem(int problem_numbers)\r\n{\r\n    double x, m, a, y, b, z, LakeLimit = 1.0f;\r\n    switch (problem_numbers)\r\n    {\r\n    case 1:\r\n        // double x, y;\r\n        cin >> x >> y;\r\n        // return (x - y) / 2.0f;\r\n        cout << (x - y) / 2.0f << fixed << setprecision(2) << endl;\r\n        break;\r\n    case 2:\r\n        // double x, m, a, y, b;\r\n        cin >> x >> m >> a >> y >> b;\r\n        // return (y / b) * (x / a) * m;\r\n        !b || !x || !y || !a ? cout << 0.00 << endl : cout << (b / y) * (a / x) * m << fixed << setprecision(2) << endl;\r\n        break;\r\n    case 3:\r\n        // double x, y, z, LakeLimit = 1.0f;\r\n        cin >> x >> y >> z;\r\n        while (true)\r\n        {\r\n            LakeLimit /= (x + 1);\r\n            --y;\r\n            if (LakeLimit <= z)\r\n            // return y;\r\n            {\r\n                y <= 0 ? cout << 0.00 << endl : cout << y << fixed << setprecision(2) << endl;\r\n                return;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\nint main()\r\n{\r\n    // freopen(\"data.txt\", \"r\", stdin);\r\n    int cases;\r\n    cin >> cases;\r\n    while (cases--)\r\n    {\r\n        int problem_numbers;\r\n        cin >> problem_numbers;\r\n        // printf(\"%.2f\\n\", JudgeProblem(problem_numbers));\r\n        // cout << JudgeProblem(problem_numbers) << fixed << setprecision(2) << endl;\r\n        JudgeProblem(problem_numbers);\r\n    }\r\n    return 0;\r\n}\r\n ','2019-11-12 22:20:25','2019-12-22 15:01:55',5),(27,'取模','<p>在被广泛采用的公开密钥体制的加密和解密计算过程中，求(x的y次方)除以m的余数是一项基本运算。在此，给定x,y,m，求x的y次方除以m的余数。</p>','<p>第一行包含一个整数n(1≤n≤100),表示测试用例的个数。 每个测试用例的输入有一行，整数x,y,m。其中，0＜x≤10的9次方， 0≤y≤10的18次方，0＜k≤10的9次方;</p>','<p>对每个测试用例输出一行。输出x的y次方除以m的余数。</p>','a:3:{i:0;s:56:\"2\r\n2 10 100\r\n1000000000 1000000000000000000 1000000000\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:7:\"24\r\n0\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include<iostream>\r\nusing namespace std;\r\nlong long pow_mod(long long a,long long i,long long n)\r\n{\r\n    if(i==0)\r\n        return 1%n;\r\n    long long temp=pow_mod(a,i>>1,n);\r\n    temp=temp*temp%n;\r\n    if(i&1)\r\n        temp=(long long)temp*a%n;\r\n    return temp;\r\n}\r\nint main()\r\n{\r\n    long long cases;\r\n    cin >> cases;\r\n    while(cases--)\r\n    {\r\n        long long x, y, m;\r\n        cin >> x >> y >> m;\r\n        cout << pow_mod(x,y,m) << endl;\r\n    }\r\n    return 0;\r\n}','2019-11-12 22:26:32','2019-11-12 23:37:12',5),(28,'字符串修改','<p>从键盘输入一个字符串（长度&lt;=40个字符），并以字符&nbsp;\'.\'结束。</p><p>例如：\'This is a book.\'&nbsp;现对该字符串进行编辑，编辑功能有：</p><p>D：删除一个字符，命令的方式为：</p><p>&nbsp; &nbsp; &nbsp;D a&nbsp;&nbsp;其中a为被删除的字符</p><p>&nbsp; &nbsp; &nbsp;例如：D s &nbsp;表示删除字符&nbsp;\'s\'&nbsp;，若字符串中有多个 \'s\'，则删除第一次出现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如上例中删除的结果为： \'Thi is a book.\'</p><p>I：插入一个字符，命令的格式为：</p><p>&nbsp;&nbsp;&nbsp; I a1 a2&nbsp;&nbsp;其中a1表示插入到指定字符前面，a2表示将要插入的字符。</p><p>&nbsp; &nbsp; 例如：I s d&nbsp;&nbsp;表示在指定字符&nbsp;\'s\'&nbsp;的前面插入字符 \'d\'&nbsp;，若原串中有多个&nbsp;\'s\'&nbsp;，则插入在最后一个字符的前面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如上例中：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;原串：\'This is a book.\'</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;插入后：\'This ids a book.\'</p><p>R：替换一个字符，命令格式为：</p><p>&nbsp; &nbsp; &nbsp;R a1 a2&nbsp; 其中a1为被替换的字符，a2为替换的字符，若在原串中有多个a1则应全部替换。</p><p>&nbsp; &nbsp; &nbsp;例如： 原串： \'This is a book.\'</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;输入命令：R o e</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;替换后的字符串为：\'This is a beek.\'</p><p>在编辑过程中，若出现被改的字符不存在时，则给出提示信息\"Not exist\"。</p>','<p>每个测试文件只包含一组测试数据，每组输入数据包含两行：</p><p>第一行，输入一个字符串，表示原串；</p><p>第二行，输入一个字符串，表示命令。</p>','<p>对于每组输入数据，输出编辑后的字符串，如果被改的字符不存在，则输出\"Not exist\"（引号不输出）。</p>','a:3:{i:0;s:22:\"This is a book.\r\nD s\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:16:\"Thi is a book.\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <stdio.h>\r\n#include <string.h>\r\nvoid Input(char *str)\r\n{\r\n    char ch;\r\n    for(int i = -1; ; )\r\n    {\r\n        ch = getchar();\r\n        str[++i] = ch;\r\n        if(ch == \'.\')\r\n        {\r\n            str[++i] = \'\\0\';\r\n            break;\r\n        }\r\n    }\r\n}\r\nvoid judge(char Menu_ch, char *str)\r\n{\r\n    char Option_ch1[2], Option_ch2[2];\r\n    switch (Menu_ch)\r\n    {\r\n        case \'D\' :\r\n        {\r\n            scanf(\"%s\", Option_ch1);\r\n            char temp[42];\r\n            int flag = 1, flaglen = -1, j = -1;\r\n            for(int i = 0; i < strlen(str); i++)\r\n                if(str[i] == Option_ch1[0])\r\n                    flaglen = i;\r\n            if(flaglen == -1)\r\n            {\r\n                printf(\"Not exist\\n\");\r\n                break;\r\n            }\r\n            for(int i = 0; i < strlen(str); i++)\r\n                if(str[i] == Option_ch1[0] && flag)\r\n                    flag = 0;\r\n                else\r\n                    temp[++j] = str[i];\r\n            temp[++j] = \'\\0\';\r\n            puts(temp);\r\n            break;\r\n        }\r\n        case \'I\' :\r\n        {\r\n            scanf(\"%s %s\", Option_ch1, Option_ch2);\r\n            char temp[42];\r\n            int flaglen = -1, flag = 1, j = -1;\r\n            for(int i = 0; i < strlen(str); i++)\r\n                if(str[i] == Option_ch1[0])\r\n                    flaglen = i;\r\n            if(flaglen == -1)\r\n            {\r\n                printf(\"Not exist\\n\");\r\n                break;\r\n            }\r\n            for(int i = 0; i < strlen(str); i++)\r\n            {\r\n                temp[++j] = str[i];\r\n                if(i + 1 == flaglen && flag)\r\n                {\r\n                    temp[++j] = Option_ch2[0];\r\n                    flag = 0;\r\n                }\r\n            }\r\n            temp[++j] = \'\\0\';\r\n            puts(temp);\r\n            break;\r\n        }\r\n        case \'R\' :\r\n        {\r\n            scanf(\"%s %s\", Option_ch1, Option_ch2);\r\n            char temp[42];\r\n            int flag = 1, flaglen = -1, j = -1;\r\n            for(int i = 0; i < strlen(str); i++)\r\n                if(str[i] == Option_ch1[0])\r\n                    flaglen = i;\r\n            if(flaglen == -1)\r\n            {\r\n                printf(\"Not exist\\n\");\r\n                break;\r\n            }\r\n            for(int i = 0; i < strlen(str); i++)\r\n                if(str[i] == Option_ch1[0])\r\n                    temp[++j] = Option_ch2[0];\r\n                else\r\n                    temp[++j] = str[i];\r\n            temp[++j] = \'\\0\';\r\n            puts(temp);\r\n            break;\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    char str[42], Menu_ch[2];\r\n    Input(str);\r\n    scanf(\"%s\", Menu_ch);\r\n    judge(Menu_ch[0], str);\r\n}','2019-11-12 22:42:42','2019-11-12 23:36:01',5),(29,'分式求和','<p>我想听话啊，但人家就是控制不住自己嘛！ ——百里玄策-白虎志</p><p>小T是一个非常无聊的人，他写了两个分数x1/y1x2/y2，他现在让小s求他们的和差积商。</p><p>小s哪里会这样的题目，于是他请教于你。</p><p>注意：如果出现负数则一律将符号放在分子上，即除分子外，答案中的其他数必须是非负数。</p>','<p>一行x1,y1 x2,y2</p>','<p>四行，每行两个整数x,y代表答案为x/y，第一行输出和，第二行输出差，第三行输出积，第四行输出商</p><p>答案为最简分数形式。如果答案为0则输出0 0</p>','a:3:{i:0;s:7:\"1 2 1 2\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:18:\"1 1\r\n0 0\r\n1 4\r\n1 1\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long int ll;\r\nll gcd(ll x, ll y)\r\n{\r\n    return y ? gcd(y, x % y) : x;\r\n}\r\nll lcm(ll x, ll y)\r\n{\r\n    return (x * y / gcd(x, y));\r\n}\r\nint main()\r\n{\r\n    ll x1, y1, x2, y2;\r\n    cin >> x1 >> y1 >> x2 >> y2;\r\n    ll LcmNum = lcm(y1, y2);\r\n    ll New_x1 = (LcmNum / y1) * x1, New_x2 = (LcmNum / y2) * x2;\r\n    ll New_x = New_x1 + New_x2, New_y = LcmNum;\r\n    ll num = gcd(New_x, New_y);\r\n    New_x /= num, New_y /= num;\r\n    !New_x ? cout << \"0 0\\n\" : cout << New_x << \" \" << New_y << endl;\r\n    New_x = New_x1 - New_x2, New_y = LcmNum;\r\n    num = gcd(New_x, New_y);\r\n    New_x /= num, New_y /= num;\r\n    !New_x ? cout << \"0 0\\n\" : cout << New_x << \" \" << New_y << endl;\r\n    New_x = x1 * x2, New_y = y1 * y2;\r\n    num = gcd(New_x, New_y);\r\n    New_x /= num, New_y /= num;\r\n    !New_x ? cout << \"0 0\\n\" : cout << New_x << \" \" << New_y << endl;\r\n    swap(x2, y2);\r\n    New_x = x1 * x2, New_y = y1 * y2;\r\n    num = gcd(New_x, New_y);\r\n    New_x /= num, New_y /= num;\r\n    !New_x ? cout << \"0 0\\n\" : cout << New_x << \" \" << New_y << endl;\r\n    return 0;\r\n}','2019-11-12 23:36:40','2019-11-12 23:43:04',5),(30,'谜题','<p>有一个5*5的网格，其中恰好有一个格子是空的，其他格子各有一个字母。一共有4种指令：A, B, L, R，分别表示把空格上、下、左、右的相邻字母移到空格中。输入初始网格和指令序列（以数字0结束），输出指令执行完毕后的网格。如果有非法指令，应输出“This puzzle has no final configuration.”例如，图3-5中执行ARRBBL0后，效果如图3-6所示。</p><figure class=\"image\"><img src=\"http://210.43.224.19/oj/upload/image/20190515/20190515170343_14021.jpg\" alt=\"\"></figure>','<p>您的程序输入包含几个谜题。每个都由其初始配置和拼图上的移动顺序来描述。每个拼图描述的前5行是起始配置。后续行给出了移动序列。<br>&nbsp; 框架显示的第一行对应于拼图中的顶部正方形线。其他行按顺序排列。框架中的空位置由空白表示。每个显示行包含正好5个字符，从最左边的正方形上的字符开始（如果最左边的正方形实际上是空帧位置，则为空白）。显示行将对应于合法的拼图。<br>&nbsp; 移动序列由As，Bs，Rs和Ls的序列表示，以表示哪个方块移动到空位置。 A表示空位置上方的方格移动; B表示空位下方的方格移动; L表示空位左边的方格移动; R表示空位置右侧的方格移动。即使由4个移动字符中的一个表示，也可能存在非法移动。如果发生非法移动，则认为该谜题没有最终配置。这个移动序列可以分布在几行上，但它总是以数字0结束。数据的结尾用字符Z表示。</p>','<p>&nbsp; 每个拼图的输出都以适当标记的数字开始（拼图＃1，拼图＃2等）。 如果拼图没有最终配置，那么应该跟随到该效果的消息。 否则应显示最终配置。<br>&nbsp; 格式化每一行以进行最终配置，以便在两个相邻字母之间存在单个空白字符。 将空方块视为字母。 例如，如果空白是内部位置，那么它将显示为3个空白的序列 - 一个用于将其与正方形分隔为左边，一个用于空位置本身，一个用于将其与正方形分隔为 对。<br>&nbsp; 通过一个空行将不同拼图记录的输出分开。</p>','a:3:{i:0;s:142:\"TRGSJ\r\nXDOKI\r\nM VLN\r\nWPABE\r\nUQHCF\r\nARRBBL0\r\nABCDE\r\nFGHIJ\r\nKLMNO\r\nPQRS\r\nTUVWX\r\nAAA\r\nLLLL0\r\nABCDE\r\nFGHIJ\r\nKLMNO\r\nPQRS\r\nTUVWX\r\nAAAAABBRRRLL0\r\nZ\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:191:\"Puzzle #1:\r\nT R G S J\r\nX O K L I\r\nM D V B N\r\nW P   A E\r\nU Q H C F\r\n\r\nPuzzle #2:\r\n  A B C D\r\nF G H I E\r\nK L M N J\r\nP Q R S O\r\nT U V W X\r\n\r\nPuzzle #3:\r\nThis puzzle has no final configuration.\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'// // C\r\n// #include <stdio.h>\r\n// #include <stdlib.h>\r\n// #include <string.h>\r\n// #define bool int\r\n// #define true 1\r\n// #define false 0\r\n// int cases;\r\n// // char Arr[5][5];\r\n// void swap(void* a, void* b, size_t size) {\r\n//     unsigned char* p1 = (unsigned char*)a;  //强制类型转换\r\n//     unsigned char* p2 = (unsigned char*)b;\r\n//     unsigned char temp;  //字节型的嫁衣\r\n//     while (size--) {\r\n//         temp = *p1;\r\n//         *p1 = *p2;\r\n//         *p2 = temp;\r\n//         p1++;\r\n//         p2++;\r\n//     }\r\n// }\r\n// void output(/*char Arr[][5]*/ char** Arr) {\r\n//     for (int i = 0; i < 5; i++) {\r\n//         for (int j = 0; j < 5; j++)\r\n//             !j ? printf(\"%c\", Arr[i][j]) : printf(\" %c\", Arr[i][j]);\r\n//         printf(\"\\n\");\r\n//     }\r\n// }\r\n// void judge(int* ArrRow, int* ArrCol, /* char Arr[][5]*/ char** Arr, char ch, bool* flag) {\r\n//     switch (ch) {\r\n//     case \'A\': {\r\n//         if (*ArrRow - 1 >= 0) {\r\n//             swap(&Arr[*ArrRow - 1][*ArrCol], &Arr[*ArrRow][*ArrCol], sizeof(char));\r\n//             (*ArrRow)--;\r\n//         }\r\n//         else\r\n//             *flag = false;\r\n//         break;\r\n//     }\r\n//     case \'B\': {\r\n//         if (*ArrRow + 1 <= 4) {\r\n//             swap(&Arr[*ArrRow + 1][*ArrCol], &Arr[*ArrRow][*ArrCol], sizeof(char));\r\n//             (*ArrRow)++;\r\n//         }\r\n//         else\r\n//             *flag = false;\r\n//         break;\r\n//     }\r\n//     case \'R\': {\r\n//         if (*ArrCol + 1 <= 4) {\r\n//             swap(&Arr[*ArrRow][*ArrCol + 1], &Arr[*ArrRow][*ArrCol], sizeof(char));\r\n//             (*ArrCol)++;\r\n//         }\r\n//         else\r\n//             *flag = false;\r\n//         break;\r\n//     }\r\n//     case \'L\': {\r\n//         if (*ArrCol - 1 >= 0) {\r\n//             swap(&Arr[*ArrRow][*ArrCol - 1], &Arr[*ArrRow][*ArrCol], sizeof(char));\r\n//             (*ArrCol)--;\r\n//         }\r\n//         else\r\n//             *flag = false;\r\n//         break;\r\n//     }\r\n//     default: {\r\n//         *flag = false;\r\n//         break;\r\n//     }\r\n//     }\r\n// }\r\n// int main() {\r\n//     char** Arr = (char**)malloc(sizeof(char*) * 5);\r\n//     for (int i = 0; i < 5; ++i)\r\n//         Arr[i] = (char*)malloc(sizeof(char) * 5);\r\n//     while (gets(Arr[0])) {\r\n//         if (Arr[0][0] == \'Z\')\r\n//             break;\r\n//         if (strlen(Arr[0]) == 4)\r\n//             Arr[0][4] = \' \';\r\n//         for (int i = 1; i <= 4; i++) {\r\n//             gets(Arr[i]);\r\n//             if (strlen(Arr[i]) == 4)\r\n//                 Arr[i][4] = \' \';\r\n//         }\r\n//         int ArrRow, ArrCol;\r\n//         ArrRow = ArrCol = -1;\r\n//         for (int i = 0; i < 5; i++) {\r\n//             for (int j = 0; j < 5; j++)\r\n//                 if (Arr[i][j] == \' \') {\r\n//                     ArrRow = i;\r\n//                     ArrCol = j;\r\n//                     break;\r\n//                 }\r\n//         }\r\n//         bool flag = true;\r\n//         char ch[9];\r\n//         while (gets(ch)) {\r\n//             for (int i = 0; i < strlen(ch); i++) {\r\n//                 if (ch[i] == \'0\')\r\n//                     break;\r\n//                 if (!flag)\r\n//                     break;\r\n//                 judge(&ArrRow, &ArrCol, Arr, ch[i], &flag);\r\n//             }\r\n//             if (ch[strlen(ch) - 1] == \'0\')\r\n//                 break;\r\n//         }\r\n//         if (cases)\r\n//             printf(\"\\n\");\r\n//         printf(\"Puzzle #%d:\\n\", ++cases);\r\n//         if (flag)\r\n//             output(Arr);\r\n//         else\r\n//             printf(\"This puzzle has no final configuration.\\n\");\r\n//     }\r\n//     return 0;\r\n// }\r\n\r\n// CPP\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint cases;\r\nvoid output(vector<string> PuzzleArr) {\r\n    if (!PuzzleArr.empty()) {\r\n        for (int i = 0; i < 5; i++) {\r\n            for (int j = 0; j < 5; j++)\r\n                !j ? printf(\"%c\", PuzzleArr[i][j]) : printf(\" %c\", PuzzleArr[i][j]);\r\n            printf(\"\\n\");\r\n        }\r\n    }\r\n}\r\nvoid judge(int& ArrRow, int& ArrCol, vector<string>& PuzzleArr, char ch, bool& flag) {\r\n    switch (ch) {\r\n    case \'A\': {\r\n        if (ArrRow - 1 >= 0) {\r\n            swap(PuzzleArr[ArrRow - 1][ArrCol], PuzzleArr[ArrRow][ArrCol]);\r\n            ArrRow--;\r\n        }\r\n        else\r\n            flag = false;\r\n        break;\r\n    }\r\n    case \'B\': {\r\n        if (ArrRow + 1 <= 4) {\r\n            swap(PuzzleArr[ArrRow + 1][ArrCol], PuzzleArr[ArrRow][ArrCol]);\r\n            ArrRow++;\r\n        }\r\n        else\r\n            flag = false;\r\n        break;\r\n    }\r\n    case \'R\': {\r\n        if (ArrCol + 1 <= 4) {\r\n            swap(PuzzleArr[ArrRow][ArrCol + 1], PuzzleArr[ArrRow][ArrCol]);\r\n            ArrCol++;\r\n        }\r\n        else\r\n            flag = false;\r\n        break;\r\n    }\r\n    case \'L\': {\r\n        if (ArrCol - 1 >= 0) {\r\n            swap(PuzzleArr[ArrRow][ArrCol - 1], PuzzleArr[ArrRow][ArrCol]);\r\n            ArrCol--;\r\n        }\r\n        else\r\n            flag = false;\r\n        break;\r\n    }\r\n    default: {\r\n        flag = false;\r\n        break;\r\n    }\r\n    }\r\n}\r\nint main() {\r\n    freopen(\"data.txt\", \"r\", stdin);\r\n    // freopen(\"dout.txt\", \"w\", stdout);\r\n    string str;\r\n    while (getline(cin, str)) {\r\n        vector<string> PuzzleArr;\r\n        PuzzleArr.clear();\r\n        if (str[0] == \'Z\')\r\n            break;\r\n        if (str.length() == 4)\r\n            str += \" \";\r\n        PuzzleArr.push_back(str);\r\n        for (int i = 1; i <= 4; i++) {\r\n            getline(cin, str);\r\n            if (str.length() == 4)\r\n                str += \" \";\r\n            PuzzleArr.push_back(str);\r\n        }\r\n        int ArrRow, ArrCol;\r\n        ArrRow = ArrCol = -1;\r\n        for (int i = 0; i < 5; i++) {\r\n            for (int j = 0; j < 5; j++)\r\n                if (PuzzleArr[i][j] == \' \') {\r\n                    ArrRow = i;\r\n                    ArrCol = j;\r\n                    break;\r\n                }\r\n        }\r\n        bool flag = true;\r\n        string ch;\r\n        while (getline(cin, ch)) {\r\n            for (int i = 0; i < ch.length(); i++) {\r\n                if (ch[i] == \'0\')\r\n                    break;\r\n                if (!flag)\r\n                    break;\r\n                judge(ArrRow, ArrCol, PuzzleArr, ch[i], flag);\r\n            }\r\n            if (ch[ch.length() - 1] == \'0\')\r\n                break;\r\n        }\r\n        if (cases)\r\n            printf(\"\\n\");\r\n        printf(\"Puzzle #%d:\\n\", ++cases);\r\n        if (flag)\r\n            output(PuzzleArr);\r\n        else\r\n            printf(\"This puzzle has no final configuration.\\n\");\r\n    }\r\n    return 0;\r\n}','2019-11-12 23:44:27','2019-11-13 20:40:03',5),(31,'循环小数','<p>&nbsp;</p>','<p>输入整数a和b（0&lt;=a&lt;=3000,1&lt;=b&lt;=3000),输出a/b的循环小数表示以及循环节长度。 例如，a=5,b=43，小数表示为0.（116279069767441860465），循环字节长度为21</p>','<p>将循环节用括号包裹起来，如果循环节长度超过50位就只输出前50位，剩下的用\"…\"代替。第二行前面有三个空格。</p>','a:3:{i:0;s:20:\"76 25\r\n5 43\r\n1 397\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:258:\"76/25 = 3.04(0)\r\n   1 = number of digits in repeating cycle\r\n\r\n5/43 = 0.(116279069767441860465)\r\n   21 = number of digits in repeating cycle\r\n\r\n1/397 = 0.(00251889168765743073047858942065491183879093198992...)\r\n   99 = number of digits in repeating cycle\r\n\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <stdio.h>\r\n#include <string.h>\r\nint s[3003], r[3003];\r\nint main()\r\n{\r\n    int a, b, i;\r\n    while (~scanf(\"%d %d\", &a, &b))\r\n    {\r\n        int n = a;\r\n        int count = 1;\r\n        memset(s, 0, sizeof(s));\r\n        memset(r, 0, sizeof(r));\r\n        r[0] = a / b;\r\n        a = a % b;\r\n        while (!s[a] && a)\r\n        {\r\n            r[count] = a * 10 / b;\r\n            s[a] = count;\r\n            count++;\r\n            a = a * 10 % b;\r\n        }\r\n        printf(\"%d/%d = %d.\", n, b, r[0]);\r\n        for (i = 1; i < count && i <= 50; i++)\r\n        {\r\n            if (s[a] == i)\r\n                printf(\"(\");\r\n            printf(\"%d\", r[i]);\r\n        }\r\n        if (a == 0)\r\n            printf(\"(0\");\r\n        if (count > 50)\r\n            printf(\"...\");\r\n        printf(\")\\n\");\r\n        printf(\"   %d = number of digits in repeating cycle\\n\\n\", !a ? 1 : count - s[a]);\r\n    }\r\n}','2019-11-12 23:59:39','2019-11-13 00:02:00',5),(32,'表单','<p>弹上膛的声音，是我唱歌的先兆。&nbsp; ——百里守约-朱雀志 小T有一张一共有n个字符串的字符串表，因为小T是神所以他可以任意修改这张表， 因为小T是个强迫症，所以他想方设法的使这些字符不同， 所以现在他进行以下操作Q次:&nbsp;</p><p>&nbsp;(1):给字符串表中加入一个字符串s。&nbsp;</p><p>&nbsp;(2):给字符串表去重，输出去掉字符串的数量。</p>','<p>第一行两个整数n,Q 后n行每行一个字符串 后Q行每行代表一个操作：&nbsp;</p><p>一操作：1 s&nbsp;</p><p>二操作：2</p>','<p>对于每个二操作，进行回答。</p>','a:3:{i:0;s:50:\"4 4\r\nplay\r\nthe\r\npubg\r\ngame\r\n1 game\r\n1 pubg\r\n2\r\n2\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:6:\"2\r\n0\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>由于出题人用win10配的数据，所以读入中会有空行出现，请忽略他们，避免应为这个而WA</p>',NULL,1,32,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint n, q, x, cf;\r\nchar s[50];\r\nset<string> st;\r\nint main()\r\n{\r\n    scanf(\"%d %d\", &n, &q);\r\n    while (n--) scanf(\"%s\", s), st.insert(s), cf++;\r\n    while (q--) {\r\n        scanf(\"%d\", &x);\r\n        if (x == 1) scanf(\"%s\", s), st.insert(s), cf++;\r\n        else printf(\"%d\\n\", cf - st.size()), cf = st.size(); }\r\n    return 0;\r\n}','2019-11-13 00:05:20','2019-11-13 00:06:06',5),(33,'拆分数','<p>105可以变成以下六种拆分数的形式：</p><p>105 = 72 + 6534 / 198<br>105 = 87 + 3456 / 192<br>105 = 87 + 9612 / 534<br>105 = 92 + 5681 / 437<br>105 = 92 + 6734 / 518<br>105 = 98 + 3647 / 521</p><p>注意它的特征：在拆分数中，1-9分别出现一次（不包含0）。105一共有六种拆分数表示方法。现在给定一个数，求这个数有多少种拆分数表示方法。</p>','<p>读入一个正整数N。（N&lt;1e6)</p>','<p>输出该数字用1-9不重复不遗漏的所有拆分数表示的全部个数。</p>','a:3:{i:0;s:3:\"105\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:1:\"6\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>提示：使用#include&lt;algorithm&gt;里的全排列模板。<br>字符串转换整型<br><code>int parse(const char* s,int pos,int len)</code><br><code>{</code><br><code>&nbsp;int f=1,sum=0;</code><br><code>&nbsp;for(int i=pos+len-1;i&gt;=pos;i--)</code><br><code>&nbsp;{</code><br><code>&nbsp;&nbsp;sum+=(s[i]-\'0\')*f;</code><br><code>&nbsp;&nbsp;f*=10;</code><br><code>&nbsp;}</code><br><code>&nbsp;return sum;</code><br><code>}</code></p>',NULL,1,8,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, total = 0, N;\r\nbool book[10];\r\nint getNum(int x, int y)\r\n{\r\n    int num = 0;\r\n    for (int i = x; i <= y; i++)\r\n        num = num * 10 + a[i];\r\n    return num;\r\n}\r\nvoid judge(int a[])\r\n{\r\n    for (int i = 1; i <= 7; i++) {\r\n        int integer = getNum(1, i);\r\n        for (int j = (9 - i) / 2 + i; j <= 9; j++) {\r\n            int fz = getNum(i + 1, j - 1), fm = getNum(j, 9);\r\n            if (integer + fz / fm == N && (fz % fm) == 0) total++;\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    cin >> N;\r\n    while (next_permutation(a + 1, a + 10))\r\n        judge(a);\r\n    cout << total;\r\n    return 0;\r\n}','2019-11-13 00:06:50','2019-11-13 00:15:14',5),(34,'Garbage Classification','<p>On the CVBB planet, garbage classification has&nbsp;been&nbsp;gradually executed to help save resources and protect the environment. Nowadays people have to be equipped with knowledge of distinguishing different types of garbage. Now, given the waste compositions of a discarded product, you are asked to determine which category it belongs to.</p><p>The waste compositions are represented as a string s consisting of only lowercase letters, where each letter represents a waste composition and has an equal proportion. Each waste composition&nbsp;in&nbsp;that&nbsp;product is in one of the three situations, dry, wet or harmful.The product can be classified by the following rules:<br>&nbsp;</p><ul><li>In case that at least 25% of its compositions is harmful, it is <strong>harmful</strong>&nbsp;garbage.</li><li>In case that at most 10% of its compositions is harmful, it is <strong>recyclable</strong>&nbsp;garbage.</li><li>In other cases, if the proportion of dry compositions in it is at least twice that of wet compositions, it is <strong>dry</strong>&nbsp;garbage, or otherwise, it is <strong>wet</strong>&nbsp;garbage.</li></ul>','<p>There are multiple test cases. The first line contains an integer T (1≤T≤50), indicating the number of test cases. Test cases are given in the following.<br>For each test case, the first line contains a non-empty string s (1≤∣s∣≤2000) consisting of only lowercase letters.<br>The second line contains a string t of length 26, consisting of only characters in {d,w,h}. The i-th character of t represents the situation of the waste composition denoted by the i-th lowercase letter, where \'d\', \'w\' and \'h\' mean dry, wet or harmful respectively.</p>','<p>For each test case, output \"Case #x: y\" in one line&nbsp;(without quotes), where x indicates the case number starting from 1, and y (y∈{Harmful,Recyclable,Dry,Wet})&nbsp;denotes the garbage&nbsp;type&nbsp;of&nbsp;the&nbsp;product&nbsp;in this test case.</p>','a:3:{i:0;s:201:\"4\r\ndqxxjefgctjgdbqxphff\r\nhddhddhhhdhdhwwddhhdwwdhhw\r\niqdvfzzdqsbdevzebego\r\nwdhddwwhwhdhhhwwdwdhwdwhhd\r\nerkjqzsmchcmbqeasadf\r\ndwddddwdwdwhdwhhdhhwwhhwdh\r\nmcxkwmxxlhbrymwawhio\r\nddhwhddhwwwdddwdwhwwwhdwdw\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:65:\"Case #1: Harmful\r\nCase #2: Recyclable\r\nCase #3: Dry\r\nCase #4: Wet\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,24,0,0,0,0,'',NULL,1,'/*\r\n * @Author: ZengChenyu\r\n * @Github: https://github.com/yuuxeun\r\n * @Date: 2019-05-07 00:20:57\r\n * @LastEditors: ZengChenyu\r\n * @LastEditTime: 2019-08-03 13:09:47\r\n */\r\n#include <bits/stdc++.h>\r\n \r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n    //    freopen(\"data.txt\", \"r\", stdin);\r\n    int Case;\r\n    cin >> Case;\r\n    for (int i = 1; i <= Case; i++)\r\n    {\r\n        string s1, s2;\r\n        cin >> s1 >> s2;\r\n        int harmfulCount, recyclableCount, dryCount, wetCount, Sum = s1.length();\r\n        harmfulCount = recyclableCount = dryCount = wetCount = 0;\r\n        for (int j = 0; j < s1.length(); j++)\r\n        {\r\n            char ch = s2[s1[j] - \'a\'];\r\n            switch (ch)\r\n            {\r\n            case \'d\':\r\n                dryCount++;\r\n                break;\r\n            case \'w\':\r\n                wetCount++;\r\n                break;\r\n            case \'h\':\r\n                harmfulCount++;\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n        }\r\n        cout << \"Case #\" << i << \": \";\r\n        if ((double)(((double)harmfulCount) / ((double)Sum)) >= 0.25)\r\n            cout << \"Harmful\\n\";\r\n        else if ((double)(((double)harmfulCount) / ((double)Sum)) <= 0.10)\r\n            cout << \"Recyclable\\n\";\r\n        else\r\n        {\r\n            if ((double)(((double)dryCount) / ((double)wetCount)) >= 2.00)\r\n                cout << \"Dry\\n\";\r\n            else\r\n                cout << \"Wet\\n\";\r\n        }\r\n    }\r\n    //system(\"pause\");\r\n    return 0;\r\n}','2019-11-13 00:18:48','2019-11-13 00:23:22',5),(35,'多项式','<p>小明最近学习了多项式和极限的概念。 现在他有两个多项式&nbsp;f(x)&nbsp;和&nbsp;g(x)，他想知道当&nbsp;x<i>x</i>&nbsp;趋近无限大的时候，f(x) / g(x)&nbsp;收敛于多少。</p>','<p>第一行一个整数&nbsp;<i>T</i>(1≤<i>T</i>≤100)&nbsp;表示数据组数。 对于每组数据，第一行一个整数&nbsp;<i>n</i>(1≤<i>n</i>≤1,000)，n-1<i>n</i>−1&nbsp;表示多项式&nbsp;<i>f</i>&nbsp;和&nbsp;<i>g</i>&nbsp;可能的最高项的次数（最高项系数不一定非0）。 接下来一行&nbsp;<i>n</i>&nbsp;个数表示多项式&nbsp;<i>f</i>，第&nbsp;<i>i</i>&nbsp;个整数<i>fi</i>(0≤<i>fi</i>≤1,000,000)&nbsp;表示次数为&nbsp;<i>i</i>−1&nbsp;次的项的系数。 接下来一行&nbsp;<i>n</i>&nbsp;个数表示多项式&nbsp;<i>g</i>，第&nbsp;<i>i</i>&nbsp;个整数&nbsp;<i>gi</i>(0≤<i>gi</i>≤1,000,000)&nbsp;表示次数为&nbsp;<i>i</i>−1&nbsp;次的项的系数。 数据保证多项式&nbsp;<i>f</i>&nbsp;和&nbsp;<i>g</i>&nbsp;的系数中至少有一项非0。</p>','<p>对于每组数据，输出一个最简分数&nbsp;<i>a</i>/<i>b</i>（<i>a</i>&nbsp;和&nbsp;<i>b</i>&nbsp;的最大公约数为1）表示答案。 如果不收敛，输出&nbsp;1/0。</p>','a:3:{i:0;s:18:\"1\r\n3\r\n2 4 0\r\n1 2 0\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:3:\"2/1\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,32,0,0,0,0,'',NULL,1,'/*\r\n * @Author: ZengChenyu\r\n * @Mail: zcy229781766@gmail.com\r\n * @Github: https://github.com/yuuxeun\r\n * @Date: 2019-05-07 00:20:57\r\n * @LastEditors: ZengChenyu\r\n * @LastEditTime: 2019-08-17 19:01:54\r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint gcd(int a, int b)\r\n{\r\n    return b ? gcd(b, a % b) : a;\r\n}\r\nint FindMaxSubscript(int *arr, int len)\r\n{\r\n    for (int i = len - 1; i >= 0; i--) if (arr[i]) return i;\r\n}\r\nint FindMax(int *arr, int len)\r\n{\r\n    for (int i = len - 1; i >= 0; i--) if (arr[i]) return arr[i];\r\n}\r\nint main()\r\n{\r\n    // freopen(\"data.txt\", \"r\", stdin);\r\n    int Case;\r\n    cin >> Case;\r\n    while (Case--)\r\n    {\r\n        int len;\r\n        cin >> len;\r\n        int a[len], b[len];\r\n        for (int i = 0; i < len; i++) cin >> a[i];\r\n        for (int i = 0; i < len; i++) cin >> b[i];\r\n        int maxaSubscript = FindMaxSubscript(a, len), maxbSubscript = FindMaxSubscript(b, len);\r\n        if (maxaSubscript > maxbSubscript) cout << \"1/0\" << endl;\r\n        else if (maxaSubscript < maxbSubscript) cout << \"0/1\" << endl;\r\n        else cout << FindMax(a, len) / gcd(FindMax(a, len), FindMax(b, len)) << \"/\" << FindMax(b, len) / gcd(FindMax(a, len), FindMax(b, len)) << endl;\r\n    }\r\n    return 0;\r\n}','2019-11-13 00:24:33','2019-11-13 00:29:25',5),(36,'Get Accept','<p>大家都应该知道Accept的意义吧，输入一个字典，寻找在这个字典中Accept这个单词出现过多少次，你就可以得到Accept。</p><p>注意：<br>Acce<br>pt<br>这样的也算是一个。（即换行但是连续，也算是一个，区分大小写）。</p>','<p>首先输入一个数字n（n&lt;=10），接下来又n行字符串（有空格），这n行字符串构成一个字典（保证每行字符串长度不会超过100个）。</p>','<p>输出Accept这个单词的个数。</p>','a:3:{i:0;s:15:\"1\r\nAcceptaccpet\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:1:\"1\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n, sum = 0;\r\n    string s;\r\n    cin >> n;\r\n    getchar();\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        string str;\r\n        getline(cin, str);\r\n        s += str;\r\n    }\r\n    size_t fi = s.find(\"Accept\", 0);\r\n    while (fi != s.npos)\r\n    {\r\n        sum++;\r\n        fi = s.find(\"Accept\", fi + 1);\r\n    }\r\n    cout << sum << endl;\r\n    return 0;\r\n}','2019-11-13 00:32:20','2019-11-25 10:58:50',5),(37,'双倍对比度','<p>灰度图像可以表示为一个像素值的二维矩阵，如600*800的图像即为一个600行、800列的矩阵，像素值为0~255之间的整数，数值越大，像素点的亮度越高。</p><p>本问题要求按公式i\'=2*(i-128)+128将对比度变为原来的两倍，其中i为原像素值。因为i\'有可能大于255，也有可能小于0，所以规定大于255的以255算，小于0的以0算。</p><p>别以为这个问题编程很容易哦，对程序时间和空间复杂度的要求需要你开动脑筋巧妙编程了！呵呵。</p>','<p>输入的第一行为测试用例数num。接下来是num个测试用例，每个测试用例分为两部分，第一行有两个整数m和n，分别为像素矩阵的行数和列数，然后是m行像素值，每行n个0～255之间的整数。</p>','<p>经过双倍对比度后的像素矩阵的值。</p>','a:3:{i:0;s:79:\"2\r\n2 3\r\n102 61 46\r\n19 31 61\r\n3 4\r\n46 34 140 158 \r\n67 221 36 89 \r\n37 147 217 130\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:57:\"76 0 0 \r\n0 0 0 \r\n0 0 152 188 \r\n6 255 0 50 \r\n0 166 255 132\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,2,2,0,0,0,0,'',NULL,1,'#include <stdio.h>\r\n#include <stdlib.h>\r\n  \r\nint main()\r\n{\r\n    int a,i,b,j,k,n,p;\r\n    scanf(\"%d\",&n);\r\n    for(p=0;p<n;p++)\r\n    {\r\n  \r\n  \r\n    scanf(\"%d %d\",&a,&b);\r\n    for (i=0;i<a;i++)\r\n    {\r\n        for(j=0;j<b;j++)\r\n        {\r\n            scanf(\"%d\",&k);\r\n            k=2*(k-128)+128;\r\n            if(k<0)printf(\"0 \");\r\n            else if(k>255)printf(\"255 \");\r\n            else printf(\"%d \",k);\r\n            //if(j<b-1)printf(\" \");\r\n        }\r\n        if(i<a-1) printf(\"\\n\");\r\n    }\r\n     printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}','2019-11-13 00:35:51','2019-11-26 09:22:02',5),(38,'顺子','<p>“跑得快”，俗称“关牌”，是流传甚广的扑克玩法。</p><p>其中的顺子，表示数字连续并且张数大于等于5张的一组牌。</p><p>现在给定某玩家拿在手里的若干张牌。请给出该牌中最长的顺子有多长。</p><p>为了简单起见，规定：</p><p>牌面的值和顺序分别为：3,4,5,6,7,8,9,10,J,Q,K,A</p><p>每种牌面值最多4张。</p><p>其中一个玩家手里最多有15张。</p>','<p>第一行有一个整数k表示测试用例的个数，k≤100。</p><p>对于每个测试用例。</p><p>第1行包含一个整数n,表示玩家手中牌的张数,n≤15。</p><p>第2行中有空格分隔的n个牌面值（不一定有序）。</p>','<p>每个测试用例输出一行。</p><p>输出顺子的最大长度。如果没有顺子，则输出none。</p>','a:3:{i:0;s:66:\"2\r\n15\r\n6 3 4 9 5 10 J 6 7 K 8 9 Q K A\r\n12\r\n3 3 3 4 4 4 5 5 5 6 6 6\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:8:\"12\r\nnone\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid Cards_Change(int i, int *cards, char *str)\r\n{\r\n    if (strlen(str) == 2)\r\n        cards[i] = 10;\r\n    else\r\n        if (str[0] >= \'0\' && str[0] <= \'9\')\r\n            cards[i] = str[0] - \'0\';\r\n        else\r\n            if (str[0] == \'J\')\r\n                cards[i] = 11;\r\n            else if (str[0] == \'Q\')\r\n                cards[i] = 12;\r\n            else if (str[0] == \'K\')\r\n                cards[i] = 13;\r\n            else if (str[0] == \'A\')\r\n                cards[i] = 14;\r\n}\r\nint main()\r\n{\r\n    int cases;\r\n    scanf(\"%d\", &cases);\r\n    while (cases--)\r\n    {\r\n        int len, maxlen = 1, maxn = 0, cards[20] = {0};\r\n        char str[3] = {0};\r\n        scanf(\"%d\", &len);\r\n        for (int i = 0; i < len; i++)\r\n        {\r\n            scanf(\"%s\", str);\r\n            Cards_Change(i, cards, str);\r\n        }\r\n        sort(cards, cards + len);\r\n        for (int i = 0; i < len - 1; i++)\r\n        {\r\n            if (cards[i] + 1 == cards[i + 1])\r\n                maxlen++;\r\n            else if (cards[i] != cards[i + 1])\r\n                maxlen = 1;\r\n            maxn = max(maxn, maxlen);\r\n        }\r\n        maxn >= 5 ? printf(\"%d\\n\", maxn) : printf(\"none\\n\");\r\n    }\r\n}','2019-11-13 01:23:41','2019-11-13 01:25:01',5),(39,'奇数幻方','<p>n阶幻方是指由1至n平方的整数，排列在n行n列的格子中，并且同时满足如下要求：</p><p>（1）每个数字必须出现且仅出现1次。</p><p>（2）每行、每列、主对角线、副对角线的数字之和均相等。</p><p>显然，对于n阶的幻方，排列方式可能并不唯一。</p><p>但是，奇数阶的幻方中，存在一个非常有趣的解。按此规律填充1至n平方的数字，就能构成幻方。该规律是：</p><p>初始时，从第1行正中位置的格子开始填数字1。其后，如果当前所填数字是n的倍数，则下一次填充位置在当前位置的正下方格。否则，下个填充位置在当前位置的右上角格。直到所有格子填充满。</p>','<p>第一行一个小于正整数200的正整数k，表示测试用例的个数。</p><p>其后k行，每行有一个奇数n，0&lt;n&lt;=201。</p>','<p>对于每个测试用例，输出按上述规律排列的幻方。注意每行的结尾没有空格。每个测试用例的输出之后有空行。</p>','a:3:{i:0;s:12:\"3\r\n1\r\n3\r\n5\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:101:\"1\r\n\r\n8 1 6\r\n3 5 7\r\n4 9 2\r\n\r\n17 24 1 8 15\r\n23 5 7 14 16\r\n4 6 13 20 22\r\n10 12 19 21 3\r\n11 18 25 2 9\r\n\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include<stdio.h>\r\n#define N 302\r\nint main() {\r\n    int i,j,n,k=1,a[N+100][N],m;\r\n    scanf(\"%d\",&m);\r\n    while(m--){\r\n            k=1;\r\n    scanf(\"%d\",&n);\r\n        for(i=0; i<n; i++)\r\n            for(j=0; j<n; j++)\r\n                a[i][j]=0;\r\n        a[i=0][j=n/2]=k;\r\n        for(k=2; k<=n*n; k++) {\r\n            i-=1;\r\n            j+=1;\r\n            if(i==-1&&j!=n) {\r\n                i=n-1;\r\n                a[i][j]=k;\r\n            } else if(j==n&&i!=-1) {\r\n                j=0;\r\n                a[i][j]=k;\r\n            } else if((i==-1&&j==n)||a[i][j]!=0) {\r\n                i+=2;\r\n                j-=1;\r\n                a[i][j]=k;\r\n            } else a[i][j]=k;\r\n        }\r\n        for(i=0; i<n; i++) {\r\n            for(j=0; j<n; j++)\r\n                if(j==0)\r\n                printf(\"%d\",a[i][j]);\r\n            else\r\n                printf(\" %d\",a[i][j]);\r\n            printf(\"\\n\");\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\r\n ','2019-11-15 13:29:21','2019-11-25 11:02:31',5),(40,'数学作业','<p>胡米兰、高佳作跟王小明三个组成了一个数学研究小组，临近期末他们需要上交一份数学作业，他们机智的把练习册撕开成一张一张的，以便于每个人都可以做。已知他们三个人做作业的效率相同，胡米兰做了5天，高佳作则做了4天，才将数学作业做完。王小明因为沉迷LOL(一款网络游戏)，无心做作业，便出了90块钱给大佬们买AD钙。请问这笔钱如何分给胡米兰和高佳作两个人较为恰当？胡米兰应该得多少元？</p>','<p>输入第一行为数据组数T（T&lt;=20）。每组数据仅一行，包含三个整数x,y,z(1&lt;=x,y&lt;=10,1&lt;=z&lt;=1000)。</p><p>x为胡米兰写作业天数，y为高佳作写作业天数，z为王小明给出的钱的额度。</p>','<p>对于每组数据，输出一个整数，即胡米兰应该得到的金额（单位：元）。</p>','a:3:{i:0;s:20:\"2\r\n5 4 90\r\n8 4 123\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:9:\"60\r\n123\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    while(n--)\r\n    {\r\n        int x,y,z;\r\n        cin >> x >> y >> z;\r\n        cout <<z*(x+x-y)/(x+y) << endl;\r\n    }\r\n}','2019-11-15 13:33:52','2019-11-15 14:01:07',5),(41,'韩信点兵','<p>相传韩信才智过人，从不直接清点自己军队的人数，只要让士兵先后以三人一排、五人一排、七人一排地变换队形，而他每次只掠一眼队伍的排尾就知道总人数了。已知总人数不小于10，不超过100 。</p>','<p>输入3个非负整数a,b,c ，表示每种队形排尾的人数（a&lt;3,b&lt;5,c&lt;7）。 多个测试案例</p>','<p>输出总人数的最小值（或报告无解，即输出NaN）。</p>','a:3:{i:0;s:16:\"2 1 6\r\n1 1 1\r\n\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:11:\"41\r\nNaN\r\n\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <stdio.h>\r\nint main() {\r\n    int a, b, c, s;\r\n    while (~scanf(\"%d%d%d\", &a, &b, &c)) {\r\n        s = a * 70 + b * 21 + c * 15;\r\n        s %= (3 * 5 * 7);\r\n        s > 100 || s < 10 ? puts(\"NaN\") : printf(\"%d\\n\", s);\r\n    }\r\n    return 0;\r\n}','2019-11-15 14:04:59','2019-11-25 22:05:26',5),(42,'RSA加密','<p>在很多情况下，我们需要对信息进行加密。特别是随着Internet的飞速发展，加密技术显得尤为重要。</p><p>很早以前，罗马人为了在战争中传递信息，频繁地使用替换法进行信息加密。然而在计算机技术高速发展的今天，这种替换法显得不堪一击。因此，密码研究人员正在试图寻找一种易于编码、但不易解码的编码规则。</p><p>目前比较流行的编码规则称为RSA，是美国麻省理工学院的三位教授发明的。这种编码规则基于求幂取模算法：对于给出的三个整数a，b，c，计算a的b次方除以c的余数。</p><p>请你写一个程序，计算ab mod c。</p>','<p>输入文件只用一行，依次为三个整数a，b，c，以空格隔开，并且1&lt;=a,b&lt;c&lt;=32768。</p>','<p>每个样例输出一行，即计算的结果。</p>','a:3:{i:0;s:8:\"2 6 11\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:3:\"9\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <stdio.h>\r\nint main() {\r\n    int a, b, c, sum = 1, i = 1;\r\n    scanf(\"%d %d %d\", &a, &b, &c);\r\n    while (i++ <= b)\r\n        sum = sum * a % c;\r\n    printf(\"%d\\n\", sum);\r\n    return 0;\r\n}','2019-11-15 15:13:12','2019-11-15 15:16:36',5),(43,'排列组合','<p>生成由 1 - 9 和 A - Z 和 a - z 字符组成的一种排列。</p>','<p>输入一个字符串s（长度小于等于100），输入两个数m，n为需要进行排列的字符串起始和结束下标</p>','<p>先把字符串从小到大排序后再按照字典顺序（即如果将每个数字看成是一个字母的话，一个排列就可看成是一个单词），每个数值之间用空格隔开。每个排列单独占一行。</p>','a:3:{i:0;s:23:\"KpQWEADB05RqFzJE\r\n5 8\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:216:\"0 A B D\r\n0 A D B\r\n0 B A D\r\n0 B D A\r\n0 D A B\r\n0 D B A\r\nA 0 B D\r\nA 0 D B\r\nA B 0 D\r\nA B D 0\r\nA D 0 B\r\nA D B 0\r\nB 0 A D\r\nB 0 D A\r\nB A 0 D\r\nB A D 0\r\nB D 0 A\r\nB D A 0\r\nD 0 A B\r\nD 0 B A\r\nD A 0 B\r\nD A B 0\r\nD B 0 A\r\nD B A 0\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid permute(string str, int k) {\r\n    if (k == str.size() - 1) {\r\n        for (auto i = 0; i < str.length() - 1; ++i)\r\n            printf(\"%c \", str[i]);\r\n        printf(\"%c\\n\", str[str.length() - 1]);\r\n    }\r\n    else if (k >= str.size())\r\n        return;\r\n    for (int i = k; i < str.size(); ++i) {\r\n        swap(str[i], str[k]);\r\n        permute(str, k + 1);\r\n    }\r\n}\r\nvoid permute(string str) {\r\n    if (str.empty())\r\n        return;\r\n    permute(str, 0);\r\n}\r\nint main() {\r\n    string str;\r\n    cin >> str;\r\n    int StrBegin, StrEnd;\r\n    cin >> StrBegin >> StrEnd;\r\n    str.erase(str.begin(), str.begin() + StrBegin);\r\n    str.erase(str.begin() + StrEnd - StrBegin + 1, str.end());\r\n    sort(str.begin(), str.end());\r\n    permute(str);\r\n    return 0;\r\n}','2019-11-15 15:24:27','2019-12-20 23:18:13',5),(44,'符号匹配','<p>输入的字符串中符号匹配情况检查。匹配的符号需要成对出现，且不嵌套。且规则匹配如下</p><p><code>,</code> -&gt; <code>.</code></p><p><code>?</code> -&gt; <code>!</code></p><p><code>&amp;</code> -&gt; <code>*</code></p><p><code>@</code> -&gt; <code>#</code></p>','<p>输入多个被检查的表达式</p>','<p>是否匹配</p>','a:3:{i:0;s:16:\",.\r\n?!,.\r\n?,!.\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:9:\"Y\r\nY\r\nN\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main() {\r\n    string str, s1 = \",?&@\", s2 = \".!*#\";\r\n    map<char, char> m;\r\n    for (auto i = 0; i < 4; ++i)\r\n        m.insert(pair<char, char>(s2[i], s1[i]));\r\n    while (cin >> str) {\r\n        stack<char> s;\r\n        bool flag = true;\r\n        for (auto i : str) {\r\n            if (s1.find(i) != string::npos)\r\n                s.push(i);\r\n            else {\r\n                if (!s.empty() && s.top() == m[i])\r\n                    s.pop();\r\n                else {\r\n                    flag = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        flag& s.empty() ? puts(\"Y\") : puts(\"N\");\r\n    }\r\n    return 0;\r\n}\r\n','2019-11-15 18:55:24','2019-11-26 14:08:08',5),(45,'数字组合','<p>输入一个正整数，将这个整数分解成若个整数，使得被所有被分解数之和为原整数，使得尽可能大分出来的数 &nbsp;比如 5 = 2 + 2 + 1 而不是 5 = 2 + 1 + 1 + 1</p>','<p>测试用例有多组，每一组用例只包含一个数字n，其中n代表需要被分解的数字。</p>','<p>对于每组数据，每个数字之间以空格隔开，每种分解之间a以回车隔开。</p>','a:3:{i:0;s:6:\"5\r\n7\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:80:\"5\r\n4 1\r\n3 2\r\n2 2 1\r\n1 1 1 1 1\r\n7\r\n6 1\r\n5 2\r\n4 3\r\n3 3 1\r\n2 2 2 1\r\n1 1 1 1 1 1 1\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>数据范围long long</p>',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint num;\r\nint subNum(int i, int Sum, int End) {\r\n    (num - Sum >= End) ? End - 1 > 0 ? i = End : i = 1 : i = num - Sum;\r\n    return i;\r\n}\r\nvoid produceNum(int& Start, int Sum, int End) {\r\n    if (Start < 1)\r\n        return;\r\n    for (int i = Start; Start > 0 && Sum < num; End = i, i = subNum(i, Sum, End))\r\n        (Sum += i) == num ? cout << i << endl : cout << i << \" \";\r\n    produceNum(--Start, Sum = 0, End);\r\n}\r\nvoid produceNum(int Start) {\r\n    cout << num << endl;\r\n    int Sum, End;\r\n    produceNum(--Start, Sum = 0, End = num);\r\n}\r\nint main() {\r\n    while (cin >> num)\r\n        produceNum(num);\r\n    return 0;\r\n}','2019-11-20 18:39:33','2019-12-22 14:08:47',5),(46,'篮球','<p>cxk最近迷上了摆篮球。她家里有m种篮球，每种篮球数量不限，她想拿出n个篮球摆成一排，并且她觉得同样的篮球不能相邻否则影响美观。cxk想数一数，一共有多种摆篮球的方法？</p>','<p>两个整数m,n( $ 1 \\leq m,n \\leq 100 $ )</p>','<p>方法数。由于数字规模巨大，对方法取模109</p>','a:3:{i:0;s:5:\"3 2\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:3:\"6\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'// (m + n) !\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int m, n, sum;\r\n    cin >> m >> n;\r\n    sum = m;\r\n    for (int i = n; i >= 2; i--)\r\n        sum *= (m - 1), sum %= 109;\r\n    cout << sum << endl;\r\n    // system(\"pause\");\r\n    return 0;\r\n}','2019-11-20 19:09:34','2019-11-25 10:47:29',5),(47,'游戏','<p>听到这么响亮的歌声，阿光怎么会闲着。于是他邀请Cuber&nbsp;QQ为大家表演节目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cuber&nbsp;QQ的唱跳才艺大家早已领略数次，于是他决定这次玩-&nbsp;-点新鲜的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cuber&nbsp;QQ邀请他的好朋友Little&nbsp;Fang上来配合他。他们要表演玩-&nbsp;-个数字游戏。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cuber&nbsp;QQ和Lttle&nbsp;Fang两人会按照游戏规则轮流写{1,2,-.,N}&nbsp;(N是-一个正整数)中的一个数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏的规则是这样的，若-个人写下数i,则另-个人只能写i+1或2i&nbsp;(i,i+1,&nbsp;2i均不超过N)。两个人中，谁先写到N这个数字，谁就能获胜。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然Cuber&nbsp;QQ为了表现自己的绅士,他让Little&nbsp;Fang先写，Little&nbsp;Fang的开场是单调而固定的,他-定会写数字1.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于表演需要，两个人一共要玩T局游戏。每局游戏都会给定提前正整数N，当然Cuber&nbsp;QQ和Lttle&nbsp;Fang的聪明程度是毋庸置疑的，所以他们都会按照最优的策略进行游戏。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你能预言他们两个人游戏的结局吗?</p>','<p>每行一个整数N&nbsp;(1≤N&nbsp;&lt;&nbsp;1018)，示当前局游戏给定的正整数。</p>','<p>对于每一局游戏,&nbsp;如果Cuber&nbsp;QQ获胜，输出Cuber&nbsp;QQ&nbsp;Win&nbsp;;否则输出Little&nbsp;Fang&nbsp;Win。</p>','a:3:{i:0;s:6:\"2\r\n3\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:31:\"Cuber QQ Win\r\nLittle Fang Win\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,NULL,NULL,'2019-11-20 19:29:25','2019-11-20 19:32:52',5),(48,'Circuit conversion','<figure class=\"image\"><img src=\"/uploads/20191120/15742506681328.png\"></figure>','<p>Multiple sets of test data</p><p>Input $ t $</p><p>If $ t = 1 $ input $ r_{1},r_{2},r_{3} $</p><p>If $ t = 0 $ input&nbsp;$ R_{12},R_{23},R_{31} $</p>','<p>if $ t = 1 $ output $ R_{12},R_{23},R_{31} $ &nbsp;</p><p>if $ t = 0 $ output &nbsp;$ r_{1},r_{2},r_{3} $&nbsp;</p><p>If the result is negative or any illogical number then output <code>NaN</code></p><p>考虑电阻为0 短路的情况 电阻为0 直接输出<code>NaN</code></p>','a:3:{i:0;s:48:\"0\r\n1 2 3\r\n1\r\n3 2 1\r\n1\r\n0 1.2 2.3\r\n1\r\n1.2 0 2.3\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:43:\"0.50 0.33 1.00\r\n11.00 3.67 5.50\r\nNaN\r\nNaN\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>Output keeps two digits</p><p>$R_{12}=\\frac{r_{1}r_{2} + r_{1}r_{3}+r_{2}r_{3}} {r_{3}} \\\\ R_{23}=\\frac{r_{1}r_{2} + r_{1}r_{3}+r_{2}r_{3}} {r_{1}} \\\\ R_{13}=\\frac{r_{1}r_{2} + r_{1}r_{3}+r_{2}r_{3}} {r_{2}} \\\\ $<br><br>and the inverse formula can be deformed by the formula above.</p><p>&nbsp;</p><p>$r_{1}=\\frac{R_{13}R_{12}}{R_{12}+R_{23}+R_{13}}$&nbsp;<br><br>$r_{2}=\\frac{R_{12}R_{23}}{R_{12}+R_{23}+R_{13}}$&nbsp;<br><br>$r_{3}=\\frac{R_{13}R_{23}}{R_{12}+R_{23}+R_{13}}$</p>',NULL,1,128,0,0,0,0,'',NULL,1,'/*#include <bits/stdc++.h>\r\nusing namespace std;\r\nclass judge {\r\npublic:\r\n    double r1, r2, r3, R12, R23, R31;\r\n    bool flag = false;\r\n    void solutionT0() {\r\n        printf(\"%.2f %.2f %.2f\\n\", (R12 * R31) / (R12 + R23 + R31), (R23 * R12) / (R12 + R23 + R31), (R23 * R31) / (R12 + R23 + R31));\r\n    }\r\n    void solutionT1() {\r\n        printf(\"%.2f %.2f %.2f\\n\", r1 + r2 + (r1 * r2) / r3, r2 + r3 + (r2 * r3) / r1, r3 + r1 + (r3 * r1) / r2);\r\n    }\r\n    void output(int t) {\r\n        flag = false;\r\n        if (t)\r\n            !floor(r1) || !floor(r2) || !floor(r3) ? puts(\"NaN\") : flag = true;\r\n        else\r\n            !floor(R12 + R23 + R31) ? puts(\"NaN\") : flag = true;\r\n        if (flag)\r\n            !t ? solutionT0() : solutionT1();\r\n    }\r\n    void judgeT(int t) {\r\n        t ? cin >> r1 >> r2 >> r3 : cin >> R12 >> R23 >> R31;\r\n        output(t);\r\n    }\r\n};\r\nint main() {\r\n    int t;\r\n    judge J;\r\n    while (cin >> t)\r\n        J.judgeT(t);\r\n    return 0;\r\n}*/\r\n#include<stdio.h>\r\nint main(){\r\n	int n;\r\n	double r1,r2,r3,R12,R13,R23;\r\n	while(scanf(\"%d\",&n)!=EOF)\r\n	{\r\n		if(n==1)\r\n		{\r\n			scanf(\"%lf%lf%lf\",&r1,&r2,&r3);\r\n			if(r1==0||r2==0||r3==0)\r\n			{\r\n				printf(\"NaN\\n\");\r\n				continue;\r\n			}\r\n            printf(\"%.2lf %.2lf %.2lf\\n\",r1*r2/r3+r1+r2,r2*r3/r1+r3+r2,r1*r3/r2+r1+r3);\r\n        } else {\r\n            scanf(\"%lf%lf%lf\",&R12,&R23,&R13);\r\n            if(R12==0||R23==0||R13==0)\r\n			{\r\n				printf(\"NaN\\n\");\r\n				continue;\r\n			}\r\n			double M = R12+R13+R23;\r\n			printf(\"%.2lf %.2lf %.2lf\\n\",R12*R13/M,R12*R23/M,R13*R23/M);\r\n        }\r\n    }\r\n    return 0;\r\n}','2019-11-20 19:50:43','2019-12-22 15:07:18',5),(49,'比大小','<p>输入两个类实数的字符串，如果 $ A = B $ 输出 &nbsp;<code>0</code> ，$ A &lt; B $ 输出 &nbsp;<code>-1</code> ，$ A &gt; B $ 输出 &nbsp;<code>1</code> 。</p>','<p>多组测试案例，每一行输入 $ A，B $ 。</p>','<p>对于每组测试用例，判断它们的大小关系，如果 $ A = B $ 输出 &nbsp;<code>0</code> ，$ A &lt; B $ 输出 &nbsp;<code>-1</code> ，$ A &gt; B $ 输出 &nbsp;<code>1</code> 。</p>','a:3:{i:0;s:55:\"3.0   2.000\r\n02.   2\r\n3.0   03.0\r\n-4.0   -3.999999999\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:11:\"1\r\n0\r\n0\r\n-1\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>$ strlen(s) &lt; 200 $</p><p>注意Linux系统下 自带字符串比较函数返回值不是 $ -1,0,1 $ 而是 为字符的差值 比如 $ a,c $ 用库函数比较返回值为 $ -2 $</p>',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid strAdd(string& str) {  // 防止 如 .0   0. 整数等特殊数据  添加签到后缀 0\r\n    bool flag = false;\r\n    if (str[0] == \'-\') {\r\n        str.erase(0, 1);\r\n        flag = true;\r\n    }\r\n    if (str == \"\" || str == \".\") str = \"0\";\r\n    if (str.find(\'.\') == string::npos) str += \".0\";\r\n    else {\r\n        if (str[0] == \'.\') str.insert(0, \"0\");\r\n        else if (str[0] == \'-\' && str[1] == \'.\') str.insert(1, \"0\");\r\n        else if (str[str.length() - 1] == \'.\') str += \"0\";\r\n    }\r\n    if (flag) str.insert(0, \"-\");\r\n}\r\nvoid strSeg(string& str)  // segmentation\r\n{\r\n    bool flag = false;\r\n    if (str[0] == \'-\') {\r\n        str.erase(0, 1);\r\n        flag = true;\r\n    }\r\n    for (int i = 0;; i = 0)\r\n        if (str[i] != \'0\') break;\r\n        else if (str[i] == \'0\') str.erase(0, 1);\r\n    reverse(str.begin(), str.end());\r\n    for (int i = 0;; i = 0)\r\n        if (str[i] != \'0\') break;\r\n        else if (str[i] == \'0\') str.erase(0, 1);\r\n    reverse(str.begin(), str.end());\r\n    if (flag) str.insert(0, \"-\");\r\n}\r\nint judge(string s1, string s2) {\r\n    int t = s1.compare(s2);\r\n    if (s1[0] == \'-\' && s2[0] == \'-\') t = -t;\r\n    if (s1[0] == \'-\') if (!s1.compare(\"-.\") & !s2.compare(\".\"))  // -. -> -0.0  . -> 0.0\r\n            return 0;\r\n    if (s2[0] == \'-\') if (!s1.compare(\".\") & !s2.compare(\"-.\")) return 0;\r\n    return t = (t < 0 ? t = -1 : t > 0 ? t = 1 : 0);\r\n}\r\nint main() {\r\n    string s1, s2;\r\n    while (cin >> s1 >> s2) {\r\n        strAdd(s1);\r\n        strAdd(s2);\r\n        strSeg(s1);\r\n        strSeg(s2);\r\n        cout << judge(s1, s2) << endl;\r\n    }\r\n    return 0;\r\n}\r\n\r\n#include <bits/stdc++.h>\r\n// #define LOCAL\r\nusing namespace std;\r\nchar a[1000], b[1000];\r\nint Strcmp(char* str1, char* str2) {\r\n    if (strcmp(str1, str2) > 0) return 1;\r\n    else if (strcmp(str1, str2) < 0) return -1;\r\n    else return 0;\r\n}\r\nvoid Dec_Zero(char* str)  // 消除小数点后面的后缀零\r\n{\r\n    char* p = str + strlen(str) - 1;  // p指向最后一个字符\r\n    if (strchr(str, \'.\'))             // 存在小数点\r\n        while (*p == \'0\' && strlen(str) != 1) *p-- = 0;  // 加上\'\\0\'\r\n    if (*p == \'.\' && strlen(str) != 1) *p = 0;  // 加上\'\\0\'\r\n}\r\nvoid judge_String(char* str1, char* str2) {\r\n    while (*str1 == \'0\' && strlen(str1) != 1)  /* 消除前导0 */ str1++;\r\n    while (*str2 == \'0\' && strlen(str2) != 1) str2++;\r\n    Dec_Zero(str1);\r\n    Dec_Zero(str2);\r\n    (strlen(str1) <= 2 && strlen(str2) <= 2 && (str1[strlen(str1) - 1] == \'0\' || str2[strlen(str2) - 1] == \'0\' || str1[strlen(str1) - 1] == \'.\' || str2[strlen(str2) - 1] == \'.\')) ? puts(\"0\") : printf(\"%d\\n\",Strcmp(str1, str2));\r\n}\r\nint main() {\r\n#ifdef LOCAL\r\n    freopen(\"data.txt\", \"r\", stdin);\r\n    freopen(\"dout.txt\", \"w\", stdout);\r\n#endif\r\n    while (~scanf(\"%s %s\", a, b)) {\r\n        char *str1 = a, *str2 = b;\r\n        if (str1[0] == \'-\' && str2[0] != \'-\') {\r\n            judge_String(str1, str2);\r\n            continue;\r\n        }\r\n        if (str1[0] != \'-\' && str2[0] == \'-\') {\r\n            judge_String(str1, str2);\r\n            continue;\r\n        }\r\n        if (str1[0] == \'-\' && str2[0] == \'-\') {\r\n            str1++;\r\n            str2++;\r\n            swap(str1, str2);\r\n        }\r\n        judge_String(str1, str2);\r\n    }\r\n    return 0;\r\n}','2019-12-16 10:34:56','2019-12-22 06:08:07',5),(50,'字符替换','<p>&nbsp;</p>','<p>一个非空字符串，以回车结束。</p>','<p>如果句子中有超过 &nbsp;3 个连续的 <code>0</code>，则将这串连续的 <code>0</code> 替换成 <code>40</code>；但如果有超过 9 个连续的 <code>0</code>，则将这串连续的 <code>0</code> 替换成 <code>100</code>。其他内容不受影响，原样输出。</p>','a:3:{i:0;s:51:\"asdasd 000  wqeqwe0000  siofw 0000000000479823749\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:42:\"asdasd 000  wqeqwe40  siofw 100479823749\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\n#include <regex>\r\nusing namespace std;\r\nvoid fun(string& str) {\r\n    int len = str.length();\r\n    int flag = 0;\r\n    for (int i = 0; i < len; i++) {\r\n        if (str[i] == \'0\')\r\n            flag++;\r\n        if (flag <= 3 && str[i + 1] != \'0\') {\r\n            for (int i = 0; i < flag; i++)\r\n                printf(\"0\");\r\n            flag = 0;\r\n        }\r\n        if (flag > 3 && flag <= 9 && str[i + 1] != \'0\') {\r\n            printf(\"40\");\r\n            flag = 0;\r\n        }\r\n        if (flag > 9 && str[i + 1] != \'0\') {\r\n            printf(\"100\");\r\n            flag = 0;\r\n        }\r\n        if (str[i] != \'0\')\r\n            printf(\"%c\", str[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\nint main() {\r\n    string s;\r\n    getline(cin, s);\r\n    fun(s);\r\n    // cout << regex_replace(regex_replace(s, regex(\"0{10,}\"), \"100\"), regex(\"0{4,}\"), \"40\") << endl;\r\n    return 0;\r\n}','2019-12-16 15:47:22','2019-12-17 13:53:23',5),(51,'字符修改','<p>“996”工作制，即每天早 9 点到岗，一直工作到晚上 9 点，每周工作 6 天。</p><p>“996”工作制的周工作时间为最低 12x6=72 小时。</p><p><strong>中国大陆工时规管现况（标准工时）：</strong> 一天工作时间为 8 小时，平均每周工时不超过 40 小时；加班上限为一天 3 小时及一个月 36 小时，逾时工作薪金不低于平日工资的 150%。而一周最高工时则为 48 小时。平均每月计薪天数为 21.75 天。</p><p>聪明的程序员会在代码注释里面很隐蔽的记录自己对996不满以及一些发表一些不和谐的言论。所以作为国家机器中的的你需要去修改其中的“ <code>996</code> ”和“ <code>251</code> ”关键字，但是作为国家机器中的内鬼想把有“ <code>996</code> ”和“ <code>251</code> ”关键字的句子的包含末尾“<code>251</code>”的单词和前两个单词替换成 <code>Great&nbsp;Firewall </code>让“ <code>996</code> ”不是那么明显。</p><p>并把每句话开头之前的所有注释字符和空格删除</p>','<p>每行一段注释，因为是 <code>Chinese</code> 程序员所以喜欢用中文写注释所以分上下两半句，用逗号&nbsp;<code>,</code>&nbsp;分隔，句号&nbsp;<code>.</code>&nbsp;结尾。单词之间用空格分隔。</p>','<p>对每一行注释，判断其是否有“ <code>996 </code>”和“ <code>251 </code>”关键字。即上句末尾的单词是“ <code>996 </code>”结尾，即下句末尾的单词是“ <code>251 </code>”结尾。如果是，就按题面方法修改之后输出，输出格式同输入；否则输出&nbsp;<code>NaN</code>，即没有找到关键字。</p>','a:3:{i:0;s:405:\"// we used mass cytometry996,and transcription factor–binding analysis to determine the functional impact of GCN2 on the myeloid phenotype and immune responses in melanoma251.\r\n// The lymphatic system extends throughout the body, with vessels that absorb protein-rich and white blood cell–filled fluid from tissues and transport it to lymph nodes.\r\n// As asteroids go996, Phaethon is a weird one251.\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:220:\"we used mass cytometry996,and transcription factor–binding analysis to determine the functional impact of GCN2 on the myeloid phenotype and immune Great Firewall.\r\nNaN\r\nAs asteroids go996, Phaethon is Great Firewall.\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,0,'#include <stdio.h>\r\n#include <string.h>\r\n// #define LOCAL\r\nchar words[1000];\r\nint main() {\r\n#ifdef LOCAL\r\n    freopen(\"data.txt\", \"r\", stdin);\r\n    freopen(\"dout.txt\", \"w\", stdout);\r\n#endif\r\n    while (gets(words) != NULL) {\r\n        char* str;\r\n        for (int i = 0; i < strlen(words); i++) {\r\n            if (words[i] != \'/\' && words[i] != \' \') {\r\n                str = words + i;\r\n                break;\r\n            }\r\n        }\r\n        int len = strlen(str);\r\n        int flagl, flagr, flag;\r\n        flagl = flagr = flag = 0;\r\n        for (int i = 0; i < len - 3; i++) {\r\n            if (str[i] == \'9\' && str[i + 1] == \'9\' && str[i + 2] == \'6\' && str[i + 3] == \',\') flagl = 1;\r\n            if (str[i] == \'2\' && str[i + 1] == \'5\' && str[i + 2] == \'1\' && str[i + 3] == \'.\') {\r\n                flagr = 1;\r\n                int cnt = 0, j;\r\n                for (j = i;; j--) {\r\n                    if (str[j] == \' \') cnt++;\r\n                    if (cnt == 3) break;\r\n                }\r\n                flag = j;\r\n            }\r\n        }\r\n        if (flagl == 1 && flagr == 1) {\r\n            for (int i = 0; i <= flag; i++) printf(\"%c\", str[i]);\r\n            puts(\"Great Firewall.\");\r\n        }\r\n        else puts(\"NaN\");\r\n    }\r\n    return 0;\r\n}','2019-12-16 18:19:50','2019-12-22 16:00:04',5),(52,'Password','<p>Given two strings of the same length and no more than 100, determine whether the letters of one of the strings can be rearranged, and then a mapping of 26 letters is made to make the two strings the same</p><p>for example,<code>JWPUDJSTVP</code> Can be obtained after rearrangement <code>WJDUPSJPVT</code>,Then map each letter to its previous letter,so it can be <code>VICTORIOUS</code></p>','<p>Multiple sets of test data</p><p>One string per line</p><p>The first line is the original string</p><p>The second line is the mapped string</p>','<p>If the output can be mapped correctly, <code>YES</code>, otherwise <code>NO</code></p>','a:3:{i:0;s:90:\"JWPUDJSTVP\r\nVICTORIOUS\r\nMAMA\r\nROME\r\nHAHA\r\nHEHE\r\nAAA\r\nAAA\r\nNEERCISTHEBEST\r\nSECRETMESSAGES\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:23:\"YES\r\nNO\r\nYES\r\nYES\r\nNO\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p><code>HEHE -&gt; HAHA</code> It is possible.</p><p><code>HEHE -&gt; ABAB</code> It is not possible.</p>',NULL,1,2,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main() {\r\n    string s1, s2;\r\n    while (cin >> s1 >> s2) {\r\n        int cnt1[26] = {0}, cnt2[26] = {0};\r\n        for (int i = 0; i < s1.length(); i++) cnt1[s1[i] - \'A\']++;\r\n        for (int i = 0; i < s2.length(); i++) cnt2[s2[i] - \'A\']++;\r\n        bool flag = false;\r\n        for (int i = 0; i < 26; i++) {\r\n            for (int j = 0; j < 26; j++) {\r\n                if (cnt1[j] == cnt2[j] || cnt1[(j + i) % 26] == cnt2[j]) flag = true;\r\n                else { flag = false; break; }\r\n            }\r\n            if (flag) break;\r\n        }\r\n        flag ? cout << \"YES\\n\" : cout << \"NO\\n\";\r\n    }\r\n    return 0;\r\n}','2019-12-16 23:12:06','2019-12-20 11:06:11',5),(53,'Number','<p>Xiaoming loves numbers which are multiple of 300.One day he got a string consisted of numbers. He wants to know how many substrings in the string are multiples of 300 when considered as decimal integers.</p>','<p>A single line consisting a string consisted of characters \'0\' to \'9\'.</p>','<p>The number of substrings that are multiples of 300 when considered as decimal integers.</p>','a:3:{i:0;s:5:\"600\r\n\";i:1;s:7:\"00900\r\n\";i:2;s:4:\"0300\";}','a:3:{i:0;s:3:\"4\r\n\";i:1;s:3:\"9\r\n\";i:2;s:3:\"6\r\n\";}',0,NULL,NULL,'<p><strong>Note that leading and trailing zeros are allowed (both in original string and substrings you chose)</strong>&nbsp;and the same substring appearing in different places can be counted multiple times.</p><p>\'600\', \'0\', \'0\', \'00\' are multiples of 300. (Note that \'0\' are counted twice because it appeared two times)&nbsp; &nbsp;让输入中的字符串为 <code>s</code>， $ strlen(s) &lt;=10 ^{7} $。 想想怎么优化算法才不会超时和超内存&nbsp; 代码的两种方法&nbsp; 内存换时间 &nbsp; 时间换内存&nbsp;</p>',NULL,1,8,0,0,0,0,'',NULL,0,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nll Remainder[3], cnt, sum;\r\nstring s;\r\nint main()\r\n{\r\n    cin >> s;\r\n    int l = s.length();\r\n    for (int i = 0; i < l; i++)\r\n        s[i] == \'0\' ? cnt++ : 0, i ? sum = sum + s[i - 1] - \'0\' : 0, Remainder[sum % 3]++, s[i] == \'0\' && s[i + 1] == \'0\' ? cnt += Remainder[sum % 3] : 0;\r\n    cout << cnt << endl;\r\n    return 0;\r\n}','2019-12-16 23:47:22','2019-12-22 16:21:40',5),(54,'逆转和','<p>反转数字是用阿拉伯数字写的数字，但数字的顺序是相反的。第一个数字变为最后一个，反之亦然。并且省略了所有前导零。</p><p>定义反转的数字 $ x $ 为 $ f(x) $ ，给定两个整数 $ A, B $，请你计算逆转和 $ f(f(A) + f(B)) $</p>','<p>第一行测试用例的数量，$ T（T≤300） $</p><p>对于每个测试用例，一行两个正整数： $ A, B (1 \\leq A, B \\leq 2^{31} - 1) $ 。</p>','<p>输出逆转和。</p>','a:3:{i:0;s:23:\"2\r\n1234 1000\r\n010 010\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:9:\"2234\r\n2\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nint main() {\r\n    int Case;\r\n    cin >> Case;\r\n    while (Case--) {\r\n        string a, b;\r\n        cin >> a >> b;\r\n        reverse(a.begin(), a.end());\r\n        reverse(b.begin(), b.end());\r\n        ll numA = 0, numB = 0;\r\n        for (int i = 0; i < a.length(); i++) numA = (numA * 10ll) + a[i] - \'0\';\r\n        for (int i = 0; i < b.length(); i++) numB = (numB * 10ll) + b[i] - \'0\';\r\n        ll sum = numA + numB, num = 0;\r\n        while (!(sum % 10)) sum /= 10;\r\n        do cout << sum % 10;\r\n        while (sum /= 10);\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}','2019-12-17 10:27:46','2019-12-20 10:28:13',5),(55,'Sort','<p>The teacher is usually busy and does not have time to rank the students\' grades.</p><p>So he found Xiaoming hoping that he could design a program to help sort.</p><p>First rank according to the total score (From large to small),</p><p>If the total score is the same, rank according to the Chinese scores (From large to small),</p><p>If the Chinese scores are the same, they are ranked according to the Math scores (From large to small).</p><p>If the Math scores are the same, they are sorted by English scores (From large to small).</p><p>If the English scores are the same, they are sorted by Science scores (From large to small).</p><p>The same goes for Science scores. Sort by student number (From small to large)</p><p>Can you help Xiaoming solve this problem?</p><p>What is the student number of the student？ Number entered!</p>','<p>Enter the number of test cases in the first line $ t $&nbsp;<br>Enter the number of students in the second line $ n（n&lt;100) $<br>The third to $ n+2 $ lines enter the classmate\'s name (less than 20 characters without spaces) Chinese score， Math score， English score，&nbsp;Science scores</p><p>Format reference sample input</p>','<p>n lines</p><p>Ranking， Name，Total score（One decimal place）</p><p>Format reference sample output</p>','a:3:{i:0;s:131:\"2\r\n2\r\nXiaoming 100 99 98 123.5\r\nxiaoxiao 88 99 66 122.5\r\n3\r\nemmmmmmm 89 98 66 231.5\r\ngosu 88 99 66 213.5\r\nxiaolaji 59 59 59 123.5\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:103:\"NO.1 Xiaoming 420.5\r\nNO.2 xiaoxiao 375.5\r\n\r\nNO.1 emmmmmmm 484.5\r\nNO.2 gosu 466.5\r\nNO.3 xiaolaji 300.5\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\n// #define LOCAL\r\nusing namespace std;\r\nstruct st {\r\n    char name[22];\r\n    double num, yw, sx, yy, lk, sum; /*  num -> 学号, yw -> 语文, sx -> 数学, yy -> 英语, lk -> 理科, sum-> 总分 */\r\n} Arr[102];\r\nint main() {\r\n#ifdef LOCAL\r\n    freopen(\"data.txt\", \"r\", stdin);\r\n    freopen(\"dout.txt\", \"w\", stdout);\r\n#endif\r\n    int cases;\r\n    scanf(\"%d\", &cases);\r\n    while (cases--) {\r\n        int n;\r\n        scanf(\"%d\", &n);\r\n        for (int i = 0; i < n; i++) {\r\n            scanf(\"%s %lf %lf %lf %lf\", &Arr[i].name, &Arr[i].yw, &Arr[i].sx, &Arr[i].yy, &Arr[i].lk);\r\n            Arr[i].sum = Arr[i].yw + Arr[i].sx + Arr[i].yy + Arr[i].lk;\r\n            Arr[i].num = i;\r\n        }\r\n        for (int i = 0; i < n - 1; i++)\r\n            for (int j = i + 1; j < n; j++)\r\n                if (Arr[i].sum < Arr[j].sum || (Arr[i].sum == Arr[j].sum && Arr[i].yw < Arr[j].yw) || (Arr[i].sum == Arr[j].sum && Arr[i].yw == Arr[j].yw && Arr[i].sx < Arr[j].sx)\r\n                    || (Arr[i].sum == Arr[j].sum && Arr[i].yw == Arr[j].yw && Arr[i].sx == Arr[j].sx && Arr[i].yy < Arr[j].yy)\r\n                    || (Arr[i].sum == Arr[j].sum && Arr[i].yw == Arr[j].yw && Arr[i].sx == Arr[j].sx && Arr[i].yy == Arr[j].yy && Arr[i].lk < Arr[j].lk)\r\n                    || (Arr[i].sum == Arr[j].sum && Arr[i].yw == Arr[j].yw && Arr[i].sx == Arr[j].sx && Arr[i].yy == Arr[j].yy && Arr[i].lk == Arr[j].lk && Arr[i].num > Arr[j].num))\r\n                    swap(Arr[i], Arr[j]);\r\n        for (int i = 0; i < n; i++)\r\n            printf(\"NO.%d %s %.1f\\n\", i + 1, Arr[i].name, Arr[i].sum);\r\n        cases ? puts(\"\") : 0;\r\n    }\r\n    return 0;\r\n}','2019-12-17 10:45:28','2019-12-17 12:47:08',5),(56,'分式和','<p>这些数字是以有理数分子/分母的形式给出的，你输出的和也必须是有理数的形式。</p>','<p>输入第一行给出一个正整数N（≤100）。随后一行按格式a1/b1 a2/b2 ...给出N个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。</p>','<p>输出上述数字和的最简形式 —— 即将结果写成整数部分 分数部分，其中分数部分写成分子/分母，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。</p>','a:3:{i:0;s:28:\"5\r\n2/5 4/15 1/30 -2/60 8/3\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:7:\"3 1/3\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long int ll;\r\nll gcd(ll a, ll b) {\r\n    a = abs(a);\r\n    b = abs(b);\r\n    return (a % b) ? gcd(b, a % b) : b;\r\n}\r\nll fun(ll a, ll b) {\r\n    a = abs(a);\r\n    b = abs(b);\r\n    return a * b / gcd(a, b);\r\n}\r\nint main() {\r\n    ll cases, a, b;\r\n    char ch;\r\n    cin >> cases;\r\n    ll fzsum = 0, fmsum = 0;\r\n    for (int i = 0; i < cases; i++) {\r\n        cin >> a >> ch >> b;\r\n        int ex = gcd(a, b);\r\n        a /= ex;\r\n        b /= ex;\r\n        if (i == 0) {\r\n            fzsum = a;\r\n            fmsum = b;\r\n        }\r\n        else {\r\n            int n = fun(fmsum, b);  //最小公倍数\r\n            fzsum = a * n / b + fzsum * n / fmsum;\r\n            fmsum = n;\r\n        }\r\n        int n = gcd(fzsum, fmsum);\r\n        fzsum /= n;\r\n        fmsum /= n;\r\n    }\r\n    int sum = fzsum / fmsum;\r\n    if (sum != 0) {\r\n        fzsum -= fmsum * sum;\r\n        if (fzsum != 0) cout << sum << \" \" << fzsum << \"/\" << fmsum << endl;\r\n        else cout << sum << endl;\r\n    }\r\n    else {\r\n        if (fzsum != 0) cout << fzsum << \"/\" << fmsum << endl;\r\n        else cout << 0 << endl;\r\n    }\r\n    return 0;\r\n}','2019-12-17 12:46:43','2019-12-20 10:29:55',5),(57,'不简单的阶乘','<p>用高精度计算出 $ S=1！+2！+3！+…+n！（n ≤ 400）$ 其中“！”表示阶乘，例如：$ 5！=5*4*3*2*1 $ 。</p>','<p>输入正整数N</p>','<p>输出计算结果S</p>','a:3:{i:0;s:3:\"3\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:3:\"9\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'',NULL,1,2,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint a[2000], b[2000], c[2000], sum[2000];\r\nvoid pplus(int *a, int *c)\r\n{\r\n    int jw = 0;\r\n    for (int i = 1; i <= 1000; i++)\r\n    {\r\n        c[i] += a[i] + jw;\r\n        jw = c[i] / 10;\r\n        c[i] %= 10;\r\n    }\r\n}\r\nvoid cheng(int *a, int c)\r\n{\r\n    int jw = 0;\r\n    for (int i = 1; i <= 1000; i++)\r\n    {\r\n        a[i] = a[i] * c + jw;\r\n        jw = a[i] / 10;\r\n        a[i] %= 10;\r\n    }\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    if(!n)\r\n    {\r\n        cout << 1 << endl;\r\n        return 0;\r\n    }\r\n    a[1] = 1;\r\n    for (int i = 1; i <= n; i++)\r\n        cheng(a, i), pplus(a, c);\r\n    bool flag = 0;\r\n    for (int i = 1000; i >= 1; i--)\r\n    {\r\n        if (c[i] != 0)\r\n            flag = 1;\r\n        if (flag)\r\n            cout << c[i];\r\n    }\r\n}','2019-12-17 13:37:04','2019-12-20 11:19:43',5),(58,'化学方程式','<p>化学方程式的平衡是化学领域的重要课题。在系统研究程序设计之后，我们想通过编写一个简单的程序来确定一个简单的化学方程式是否平衡。为减少难度，我们保证化学方程式不包含数字和 括号，但要加上加号。这不是很有趣吗？</p><p>另外，我们需要注意以下几点。</p><p>1，元素可以包含一个或两个字母。 如果是字母，请大写。 如果是两个字母，则第一个大写字母和第二个小写字母。例如，C和Ag</p><p>2，我们只需要判断两侧元素的数目是否守恒。 该方程实际上可能不存在。</p>','<p>第一行是数字n，代表测试用例组的数量。</p><p>在n行之后，每行都有一个化学方程式。</p>','<p>如果方程是平衡的（方程不一定实际存在），则输出Yes，否则输出No</p>','a:3:{i:0;s:24:\"2\r\nCN=C+N\r\nAg+Cu=Au+Cg\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:9:\"Yes\r\nNo\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>有一些简单的方法可以对一些简单的测试用例进行评分。</p>',NULL,1,128,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\n#define ll long long\r\nusing namespace std;\r\nint main() {\r\n    int t;\r\n    cin >> t;\r\n    while (t--) {\r\n        int n1 = 0, n2 = 0;\r\n        string str, s1, s2;\r\n        set<string> Set;\r\n        cin >> str;\r\n        int len = str.length();\r\n        for (int i = 0; i < len; i++)\r\n            if (str[i] == \'=\')\r\n                str[i] = \' \';\r\n        stringstream ss(str);\r\n        ss >> s1, ss >> s2;\r\n        map<string, int> mp1, mp2;\r\n        len = s1.length();\r\n        for (int i = 0; i < len; i++)\r\n            if (s1[i] == \'+\')\r\n                s1[i] = \' \';\r\n        stringstream ss1(s1);\r\n        string str1;\r\n        while (ss1 >> str1) {\r\n            len = str1.length();\r\n            for (int i = 0; i < len; i++) {\r\n                string a = \"\";\r\n                if (str1[i] >= \'A\' && str1[i] <= \'Z\') {\r\n                    a += str1[i];\r\n                    if (str1[i + 1] >= \'a\' && str1[i + 1] <= \'z\')\r\n                        a += str1[i + 1];\r\n                    n1++;\r\n                    mp1[a] += 1;\r\n                    Set.insert(a);\r\n                }\r\n            }\r\n        }\r\n        len = s2.length();\r\n        for (int i = 0; i < len; i++)\r\n            if (s2[i] == \'+\')\r\n                s2[i] = \' \';\r\n        stringstream ss2(s2);\r\n        string str2;\r\n        while (ss2 >> str2) {\r\n            len = str2.length();\r\n            for (int i = 0; i < len; i++) {\r\n                string a = \"\";\r\n                if (str2[i] >= \'A\' && str2[i] <= \'Z\') {\r\n                    a += str2[i];\r\n                    if (str2[i + 1] >= \'a\' && str2[i + 1] <= \'z\')\r\n                        a += str2[i + 1];\r\n                    n2++;\r\n                    mp2[a] += 1;\r\n                }\r\n            }\r\n        }\r\n        int flag = 1;\r\n        if (n1 == n2) {\r\n            for (set<string>::iterator it = Set.begin(); it != Set.end(); it++)\r\n                if (mp1[*it] != mp2[*it])\r\n                    flag = 0;\r\n        }\r\n        else\r\n            flag = 0;\r\n        puts(flag ? \"Yes\" : \"No\");\r\n    }\r\n    return 0;\r\n}','2019-12-18 14:11:26','2019-12-18 14:15:29',5),(59,'Polynomial','<p>Xiao Ming recently learned the concepts of polynomials and limits. Now that he has two polynomials $ f (x) $ and $ g (x) $ , he wants to know how much $ f (x) / g (x) $ converges as $ x $ approaches infinity.</p>','<p>The first line of an integer $ T (1≤T≤100) $ represents the number of data sets. For each set of data, the first row is an integer $ n (1≤n≤1,000) $ , and $ n-1 $ represents the degree of the highest possible polynomial $ f $ and $ g $ (the coefficient of the highest term is not necessarily non-zero). The next line of n numbers represents the polynomial $ f $, and the $ i-th $ integer $ fi (0≤fi≤1,000,000) $ represents the coefficient of the term of degree $ i−1 $. The next line of $ n $ numbers represents the polynomial $ g $, and the $ i-th $ integer $ gi (0≤gi≤1,000,000) $ represents the coefficient of the term of degree $ i−1 $. The data guarantee that at least one of the coefficients of the polynomials f and g is nonzero.</p>','<p>For each set of data, output a simple score $ a / b $ (the greatest common divisor of $ a $ and $ b $ is $ 1 $ ) for the answer. If it does not converge, $ 1/0 $ is output.</p>','a:3:{i:0;s:46:\"3\r\n2\r\n0 2\r\n1 0\r\n2\r\n1 0\r\n0 2\r\n3\r\n2 4 0\r\n1 2 0\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}','a:3:{i:0;s:15:\"1/0\r\n0/1\r\n2/1\r\n\";i:1;s:0:\"\";i:2;s:0:\"\";}',0,NULL,NULL,'<p>It\'s easier to do without looking at the description</p><p>&nbsp;$ f(x) = 2xf(x)=2x $</p><p>&nbsp;$ g(x) = 1g(x)=1 $</p><p>&nbsp;$ f(x) = 1f(x)=1 $</p><p>&nbsp;$ g(x) = 2xg(x)=2x $</p><p>&nbsp;$ f(x) = 4x + 2f(x)=4x+2 $</p><p>&nbsp;$ g(x) = 2x + 1g(x)=2x+1 $</p>',NULL,1,32,0,0,0,0,'',NULL,1,'#include <bits/stdc++.h>\r\nusing namespace std;\r\nint gcd(int a, int b) {\r\n    return b ? gcd(b, a % b) : a;\r\n}\r\nint FindMaxSubscript(int* arr, int len) {\r\n    for (int i = len - 1; i >= 0; i--)\r\n        if (arr[i])\r\n            return i;\r\n}\r\nint FindMax(int* arr, int len) {\r\n    for (int i = len - 1; i >= 0; i--)\r\n        if (arr[i])\r\n            return arr[i];\r\n}\r\nint main() {\r\n    int Case;\r\n    cin >> Case;\r\n    while (Case--) {\r\n        int len;\r\n        cin >> len;\r\n        int a[len], b[len];\r\n        for (int i = 0; i < len; i++) cin >> a[i];\r\n        for (int i = 0; i < len; i++) cin >> b[i];\r\n        int maxaSubscript = FindMaxSubscript(a, len), maxbSubscript = FindMaxSubscript(b, len);\r\n        if (maxaSubscript > maxbSubscript) cout << \"1/0\" << endl;\r\n        else if (maxaSubscript < maxbSubscript) cout << \"0/1\" << endl;\r\n        else cout << FindMax(a, len) / gcd(FindMax(a, len), FindMax(b, len)) << \"/\" << FindMax(b, len) / gcd(FindMax(a, len), FindMax(b, len)) << endl;\r\n    }\r\n    return 0;\r\n}','2019-12-18 16:00:26','2019-12-20 10:31:26',5);
/*!40000 ALTER TABLE `polygon_problem` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-01-06  0:15:53
